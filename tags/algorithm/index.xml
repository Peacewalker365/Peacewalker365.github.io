<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Algorithm - Tag - myStack</title>
        <link>https://Peacewalker365.github.io/tags/algorithm/</link>
        <description>Algorithm - Tag - myStack</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://Peacewalker365.github.io/tags/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>Bellman Ford</title>
    <link>https://Peacewalker365.github.io/bellman-ford/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/bellman-ford/</guid>
    <description><![CDATA[Bellman-Ford Generic S.P. Algo review  Complexity could be exponential time (even for +ve weights) might not even terminate if there is a -ve weight cycle reachable from the source  Bellman-Ford(G,W,s) to solve prob 2 above 1 2 3 4 5 6 7  Initialize() for i=1 to |v|-1 for each edge(u,v)âˆˆE Relax(u,v,w) for each edge(u,v)âˆˆE if d[v] &gt; d[u] + w(u,v) then report -ve cycle exists    O(VE) Correctness  Theorem: If G = (V,E) contains no -ve weight cycles then after B-F executes, d[v] = áºŸ[s,v] for all vâˆˆV Corollary: If a value d[v] fails to converge after |v|-1 passes, there exists a -ve weight cycle reachable from s Proof by induction  Proof      Notice B-F algo doesn&rsquo;t sovle the -ve cycle but give an option to abort for the sake of termination]]></description>
</item><item>
    <title>BFS</title>
    <link>https://Peacewalker365.github.io/breadth-first-search-bfs/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/breadth-first-search-bfs/</guid>
    <description><![CDATA[Breadth-First Search (BFS) Basic Graph Review Graph search  find paths from one state to another  Recall: graph G = (V,E)  V = set of vertices E = set of edges  undirected e = {v,w} unordered pairs directed e = (v,w) ordered pairs    Aplications of graph search  web crawling social networking (search the friend near you than friends of a friend) network broadcast garbage collection model checking check mathematical conj.]]></description>
</item><item>
    <title>Complexity</title>
    <link>https://Peacewalker365.github.io/computational-complexity/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/computational-complexity/</guid>
    <description><![CDATA[Computational Complexity P = {problems solvable in polynomial}
NP = {decision problems solvable in poly time via a &ldquo;lucky&rdquo; algorithm, which a Nondeterministic model, algorithm makes guesses and output yes or no, guesses are guaranteed to lead to a yes if possible} or {decision problem with &ldquo;solution&rdquo; that can be &ldquo;checked&rdquo; in polynomial time, whenever the answer is yes, you can prove it and check it in poly time}
EXP = {problems solvable in exponential time 2nC}]]></description>
</item><item>
    <title>DP</title>
    <link>https://Peacewalker365.github.io/dynamic-programming-i-fibonacci-shortest-paths/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/dynamic-programming-i-fibonacci-shortest-paths/</guid>
    <description><![CDATA[Dynamic Programming I: Fibonacci, Shortest Paths Dynamic programming (DP)  DP â‰ˆ careful brute force DP â‰ˆ guessing + recurrsion + memoization time = #subprobs â€¢ time of each subprob (treating recurrsive calls as Î˜(1) since we only pay it on the first call)  Fibonacci numbers 1 2 3 4  fib(n): if nâ‰¤2: f=1 else: f=fib(n-1)+fib(n-2) return f   T(n) = T(n-1) + T(n-2) + c â‰¥ 2T(n-2) = Î˜(2n/2)]]></description>
</item><item>
    <title>DP 2</title>
    <link>https://Peacewalker365.github.io/dynamic-programming-ii-text-justification-blackjack/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/dynamic-programming-ii-text-justification-blackjack/</guid>
    <description><![CDATA[Dynamic Programming II: Text Justification, Blackjack 5 &ldquo;easy&rdquo; steps to DP  define subprob guess(part of solution) relate subprob solution (recurrence) recurse &amp; memoize or build DP table bottom-up  acyclic topo order time = #subprobsâ€¢time per subprob   solve original problem?  Note
Text justification  split text into &ldquo;good&rdquo; lines text = list of words badness(i-j): how bad it is as words[i:j] fit a line
if don&rsquo;t fit =&gt; infinity]]></description>
</item><item>
    <title>Karp-Rabin</title>
    <link>https://Peacewalker365.github.io/table-doubling-karp-rabin/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/table-doubling-karp-rabin/</guid>
    <description><![CDATA[Table Doubling, Karp-Rabin how to choose m?
  want m = Î˜(n) =&gt; ð›¼ = Î˜(1)
  Idea: start small: m = 8
 grow/shrink as necessary If m &gt; n, grow a table  make table of size m' build new hash f' rehash insert them in new table T' Î˜(n+m+m')      in the case above
 if m' = m + 1  the cost of n insert is Î˜(1+2+3+&hellip;+n) = Î˜(n2)   if m' = 2m Oh, Golden  cost of n insert is Î˜(1+2+4+8+&hellip;+n) = Î˜(n)      Table Doubling =&gt; Amortization]]></description>
</item><item>
    <title>Newton&#39;s Method</title>
    <link>https://Peacewalker365.github.io/square-roots-newtons-method/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/square-roots-newtons-method/</guid>
    <description><![CDATA[Square Roots, Newton&rsquo;s Method Square Roots  recall the sqrt(2) problem
xi+1 = (xi + a/xi) / 2
Notice the division in it
that&rsquo;s what we&rsquo;ll settle down  Error Analysis of Newton&rsquo;s Method  xn = âˆša (1 + ð›†n) ð›†n may +/-
xn+1 = ( âˆša ( 1 + ð›†nÂ ) + a / ( âˆša ( 1 + ð›†nÂ ) ) / 2
= ( âˆša ( 1 + ð›†n ) + 1 / ( 1 + ð›†n ) ) / 2]]></description>
</item><item>
    <title>Optimized Dijkstra</title>
    <link>https://Peacewalker365.github.io/speeding-up-dijkstra/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/speeding-up-dijkstra/</guid>
    <description><![CDATA[Speeding up Dijkstra Optimize Dijkstra Single-Source, single target: s -&gt; t 1 2 3 4 5 6  Initialize() where d[s] = 0 d[uâ‰ s] = âˆž Q &lt;- V[a] while Q â‰  ðœ‘ do u &lt;- EXTRACT-MIN(Q) for each vertex vâˆˆAdj[u] do Relax(u,v,w)   you can add (stop if u == t) rather than quit until Q is null to accelerate it
Bi-Directional Search Alternate forward search from s and backward search from t, and we sorts of doubles all the data structures, like we have Qf and Qb, df[u] and db[u] &hellip;]]></description>
</item><item>
    <title>Single-Source Shortest Paths Problem</title>
    <link>https://Peacewalker365.github.io/single-source-shortest-paths-problem/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/single-source-shortest-paths-problem/</guid>
    <description><![CDATA[Single-Source Shortest Paths Problem Motivation G(V,E,W) where V is the vertices, E is the edges, W is the weights
Dijkstra (for non-negative weight edges)  O(VlgV + E) where E = O(V2)  Bellmen-Ford  O(VE)  Weighted graphs   path p = &lt; v0, v1,&hellip;, vk&gt;
( vi, vi+1 ) âˆˆ E for 0 â‰¤ i &lt; k
w(p) = âˆ‘w( vi, vi+1 ) from 0 to k-1]]></description>
</item><item>
    <title>Topics in Algorithm Research</title>
    <link>https://Peacewalker365.github.io/topics-in-algorithms-research/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/topics-in-algorithms-research/</guid>
    <description><![CDATA[Topics in Algorithms Research Heometric folding algorithm  folding a crease pattern -&gt; NP-complete design a crease pattern from a folded shape -&gt; P   ]]></description>
</item></channel>
</rss>
