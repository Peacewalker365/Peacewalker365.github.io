<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Algorithm - Tag - myStack</title>
        <link>https://Peacewalker365.github.io/tags/algorithm/</link>
        <description>Algorithm - Tag - myStack</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://Peacewalker365.github.io/tags/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>Bellman Ford</title>
    <link>https://Peacewalker365.github.io/bellman-ford/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/bellman-ford/</guid>
    <description><![CDATA[Bellman-Ford Generic S.P. Algo review  Complexity could be exponential time (even for +ve weights) might not even terminate if there is a -ve weight cycle reachable from the source  Bellman-Ford(G,W,s) to solve prob 2 above 1 2 3 4 5 6 7  Initialize() for i=1 to |v|-1 for each edge(u,v)âˆˆE Relax(u,v,w) for each edge(u,v)âˆˆE if d[v] &gt; d[u] + w(u,v) then report -ve cycle exists    O(VE) Correctness  Theorem: If G = (V,E) contains no -ve weight cycles then after B-F executes, d[v] = áºŸ[s,v] for all vâˆˆV Corollary: If a value d[v] fails to converge after |v|-1 passes, there exists a -ve weight cycle reachable from s Proof by induction  Proof      Notice B-F algo doesn&rsquo;t sovle the -ve cycle but give an option to abort for the sake of termination]]></description>
</item><item>
    <title>BFS</title>
    <link>https://Peacewalker365.github.io/breadth-first-search-bfs/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/breadth-first-search-bfs/</guid>
    <description><![CDATA[Breadth-First Search (BFS) Basic Graph Review Graph search  find paths from one state to another  Recall: graph G = (V,E)  V = set of vertices E = set of edges  undirected e = {v,w} unordered pairs directed e = (v,w) ordered pairs    Aplications of graph search  web crawling social networking (search the friend near you than friends of a friend) network broadcast garbage collection model checking check mathematical conj.]]></description>
</item><item>
    <title>Karp-Rabin</title>
    <link>https://Peacewalker365.github.io/table-doubling-karp-rabin/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/table-doubling-karp-rabin/</guid>
    <description><![CDATA[Table Doubling, Karp-Rabin how to choose m?
  want m = Î˜(n) =&gt; ð›¼ = Î˜(1)
  Idea: start small: m = 8
 grow/shrink as necessary If m &gt; n, grow a table  make table of size m' build new hash f' rehash insert them in new table T' Î˜(n+m+m')      in the case above
 if m' = m + 1  the cost of n insert is Î˜(1+2+3+&hellip;+n) = Î˜(n2)   if m' = 2m Oh, Golden  cost of n insert is Î˜(1+2+4+8+&hellip;+n) = Î˜(n)      Table Doubling =&gt; Amortization]]></description>
</item><item>
    <title>Newton&#39;s Method</title>
    <link>https://Peacewalker365.github.io/square-roots-newtons-method/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/square-roots-newtons-method/</guid>
    <description><![CDATA[Square Roots, Newton&rsquo;s Method Square Roots  recall the sqrt(2) problem
xi+1 = (xi + a/xi) / 2
Notice the division in it
that&rsquo;s what we&rsquo;ll settle down  Error Analysis of Newton&rsquo;s Method  xn = âˆša (1 + ð›†n) ð›†n may +/-
xn+1 = ( âˆša ( 1 + ð›†nÂ ) + a / ( âˆša ( 1 + ð›†nÂ ) ) / 2
= ( âˆša ( 1 + ð›†n ) + 1 / ( 1 + ð›†n ) ) / 2]]></description>
</item><item>
    <title>Topics in Algorithm Research</title>
    <link>https://Peacewalker365.github.io/topics-in-algorithms-research/</link>
    <pubDate>Sat, 25 Dec 2021 00:00:00 &#43;0000</pubDate><author>
                    <name>PceWlkr</name><uri>https://github.com/Peacewalker365</uri></author><guid>https://Peacewalker365.github.io/topics-in-algorithms-research/</guid>
    <description><![CDATA[Topics in Algorithms Research Heometric folding algorithm  folding a crease pattern -&gt; NP-complete design a crease pattern from a folded shape -&gt; P   ]]></description>
</item></channel>
</rss>
