# Linux

# Linux
### Installation
- VMware

### Partition Editior
1. 主分区最多只能有4个
2. 扩展分区只能有一个
	1. 主分区加扩展分区只能有4个
	2. 扩展分区不能写入数据 只能包含逻辑分区 逻辑分区内可以写入数据
3. 格式化（高级格式化）又称逻辑格式化 
	1. 格式化的目的就是为了写入
	2. 就像把柜子中打入隔断（遵守某种规则划分block）
	3. 当用户读取文件的时候 调用分区表 每个文件有一个inode 从而找到对应文件
	4. 格式化就是制定和实行这一种特定的规则 并创造inode表的过程
4. 建立硬件设备文件（自动的 但我们要看懂）
	1. 第一子目录dev下 （linux一切皆文件）
	2. IDE硬盘 _dev_hd/[a-d]
	3. SCSI_SATA_USB硬盘 _dev_sd/[a-p]
	4. 等等......
5. 分区设备文件名
	1. _dev_hda1（IDE硬盘接口）
	2. 等等........
6. 挂载（类似win下的分配盘符，写入挂载点）
  1. 必须分区
        1. 根分区
      - 保证有地方可以写入
        2. swap分区（其实就是虚拟内存 交换分区 一般设置内存2倍 ）
       - 当根分区不足时 有备用分区写入
        3. 推荐分区
      1. /boot（启动分区）专门保存启动时的数据 以防根分区满了 无法启动
7. 文件系统结构
	1. /
		1. /boot
		2. /etc
			1. passwd
			2. shadow
			3. group
		3. /home
	2. 注意
		1. linux可以给任意文件层级分配分区
		2. 比如给_分配_dev_sda3 然后给_home分配dev/sda2 等等


### 远程登录管理
- 联网

1. 桥接（利用真实网卡，人多可能有IP地址冲突）
2. host only
3. VMnet

- 配置网卡
  - ifconfig -ens0 192.168.118.2

  - 虚拟机的网卡一定要和host在一个网段 否则无法通信
  - 注意 这种方法只是临时生效 重启之后就会reset

- 远程连接工具

  - SecureCRT

    1. quick connect

    2. Username: root
       1. 一般不推荐用root登陆，因为权限过大，容易出问题，最好用一个普通账户登录

- 选择带save的

- 进入了之后即可进入远程操控

- 操作谨慎，例如关机重启更改ip地址

- 如果有乱码 把字体改成任何一个中文字体 让他包含乱码的字符集，然后刷新

- 输入df 查看分区情况

- Winscp 文件拷贝工具

  1. 登陆 文件协议 SFTP

  2. 图形化界面 带加密 简单安全

- xshell或者xftp


### 注意事项
1. Linux区分大小写
2. Linux中所有文件以稳健的形式保存，包括硬件！一切皆文件
3. Linux不靠扩展名区分文件 靠的是文件权限
	1. 注意：有一些为了使用方便的扩展名是给操作者看的 实际linux不需要
	2. 压缩包 gz bz2 配置文件conf 脚本文件sh
	3. 安全 因为病毒没有执行权限
	4. Linux所有存储设备都必须挂在之后才能使用，包括硬盘 u盘 光盘

### 服务器的维护和建议
2. 服务器注意事项
	1. 远程服务器不许关机，只能重启...因为远程关了没法开
		1. 推荐使用shutdown -r now
		2. 在重启前 进行几次-sync
	2. 重启时应正确关闭服务！
	3. 不要再服务器访问高峰运行高负载命令
	4. 远程配置防火墙时不要把自己踢出服务器
		1. 防火墙是个门岗 过滤器，靠ip地址 mac号 端口 协议类型 数据包中的数据等等 并不能防病毒 不能替代放毒软件
		2. 配置不好 可能把自己踢出去了 那就凉了
			1. 有一个笨办法 设置每五分钟清空防火墙设置 知道配置结束 以防把自己踢出去进不来了
	5. 制定合理的密码规范并定期更新
	6. 合理分配权限
		1. 在够用的情况下尽可能少 就像系统启动的服务越少越好
	7. 定期备份重要数据和日志
		1. 鸡蛋不要放在同一个篮子里




### 开源软件
Apache — web服务器
Nginx — web服务器
MySQL — 数据库（SQLsever，Oracle贵）
Samba — Linux和windows之间的内网文件服务器
MongoDB/redis — NoSQL数据库（不遵守SQL规则 辅助MySQL）
Sphinx — 中文分词（主要是用来做搜索引擎）（见喜欢迎 —> 见喜｜欢迎）

	1. 免费
	2. 可以获得源代码
	3. 自由传播，改良，甚至销售

支撑互联网的开源技术LAMP or LNMP：Linux Apache/Nginx MySQL PHP
现在还是这样么？ 需要验证

### 一级目录

  1. _bin_ 存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行

  2. _sbin_ 保存和系统环境设置相关的命令，只有超级用户才可以使用他们进行系统环境设置

  3. _usr_bin/ 存放系统命令的目录，普通用户和超级用户都可以执行，这些命令和系统启动无关，在单用户模式下无法执行

  4. _usr_sbin/ 存放根文件系统不必要的系统管理命令，例如多数服务程序，只有超级用户可以使用

  5. _boot_ 系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 强烈建议备份

  6. _dev_ 设备文件的保存位置

  7. _etc_ 配置文件的保存位置，系统内所有采用默认安装方式（rpm安装）的服务配置文件全都保存在这个目录当中，如用户账户密码，服务的启动脚本，常用服务的配置文件等 强烈建议备份

  8. _home_ 普通用户的家目录

  9. _lib_ 系统调用函数库保存位置

  10. _lost+found_ 当系统以外崩溃或机器意外关机，会产生一些文件碎片在这里，可以用作备份恢复等

  11. _media_ 挂载目录 挂在额外设备

  12. _mnt_ 挂载目录挂载NFS服务的共享目录

      1. 注意 只有空目录才能作为挂载点

      2. 挂哪都行

  13. _misc_ 挂载目录 不大用

  14. _opt_ 第三方安装的软件的保存位置，不过现在已吧还是把软件放在usr_local_中，算是业内的潜规则

  15. _proc_ 虚拟文件系统 该目录中的数据并不保存在硬盘里 在内存里 主要是内存的进程 内核 设备状态 cpu信息等等等等

  16. _sys_ 内核相关 虚拟文件系统 在内存中

  17. _root_ 超级用户的家目录

  18. _srv_ 服务数据目录 服务 应用在启动之后产生的一切数据

  19. _tmp_ 临时目录 系统存放的临时文件 最好每次开机后清空

  20. _usr_ 系统软件资源目录 注意usr不是user的缩写 而是 Unix Software Resource的缩写 系统中安装的软件大多数都保存在这里

  21. _var_ 动态数据保存位置 其实就是日志 邮件等 主要保存缓存 日志以及软件所产生的文件



### 二级目录
1. usr_lib_ 应用程序调用的函数库保存位置
2. usr_local_ 安装位置 手工安装软件保存位置，一般建议把源码包软件安装在这个位置
3. usr_share_ 应用程序的资源文件，如帮助文档，说明文档和字体目录
4. usr_src_ 源程序位置 我们手动下载的源码包和内核源码包可以保存在这里 不过我觉得 usr_local_src/ 好像更好 这样可以跟内核分开放
5. usr_src_kernels/ 内核源码的保存位置
6. _var_www_html_ rpm包安装的Apache的网页主目录
7. _var_lib/ 程序运行时需要调用或改变的数据保存位置，如MySQL的数据保存在_var_lib_mysql_中
8. _var_log/ 系统日志的保存位置
9. _var_run/ 一些服务和程序运行后，它们的PID（进程ID）保存位置。是_run_目录的软链接
10. _var_spool/ 防止队列数据的目录，就是排队等待其他程序使用的数据，比如邮件队列和打印队列
11. _var_spool_mail_ 新收到的邮件队列保存位置，系统新收到的邮件回保存在这里
12. _var_spool_cron_ 系统的定时任务队列保存位置，系统的计划任务会保存在这里


## 常用命令
### 命令的基本格式
1. 命令的提示符
  - [root@localhost ~] #

  - []：这是提示符的分隔符号，没有特殊含义

  - root：显示当前的登录用户

  - @：分隔符号 没有特殊含义

  - localhost：当前系统的简写主机名 完全的主机名可以通过hostname查看

  - ~：当前所在目录的最后一级目录

  - 井号是超级用户的命令提示符 $是普通用户的

2. 命令的基本格式
  - 命令  [选项] [参数]

  1. ls -l
  	1. 七列数据
        		1. 权限
                 		2. 引用计数
        			1. 文件的引用计数代表该文件的硬链接个数
                        
                        
                                 			2. 目录的引用计数代表该目录有多少个一级子目录（注意 有隐藏子目录）
                		3. 所有者 默认为文件的创建者
                         		4. 所属组 默认所属组是文件建立用户的有效组，一般情况下是建立用户的所属组
                        		5. 文件大小 默认单位byte
                        			1. -h 人性化显示 自动优化大小显示
                                               		6. 修改时间和访问时间中最紧的
                                		7. 文件名
                  
                        **选项是用于调整命令的功能的**
                        ls下支持的部分常用选项
                        	-a 显示所有文件
                        	—color=when 支持颜色输出 when的默认值是always，也可以是never或者auto
                        	-d 显示目录信息，而不是目录下的文件
                        	-h 人性化显示 按照我们的习惯显示文件大小
                        	-i 显示文件的i节点号
                        	-l 长格式显示
                        	等等

**参数是命令的操作对象，如果省略参数，是因为有默认参数**

### 目录操作命令
1. ls命令
2. cd命令
	1. change directory
	2. 绝对路径和相对路径
		1. 绝对路径：以根目录为参照物，从根目录开始一级一级进入目录
		2. 相对路径：以当前目录作为参照物进行目录查找
	3. cd后面参数从/开始就是绝对路径 否则就是相对目录 新手建议用绝对命令
	4. 简化用法
		1. ~代表用户的家目录
		2. -代表上次目录
		3. .代表当前目录
		4. ..代表上级目录
	5. pwd 显示当前路径
3. mkdir新建目录
	1. 除了家目录和临时目录最好不要新建目录 不安全
	2. make directories
	3. -p递归建立所需目录
		1. mkdir 123/234/345
		2. 一级一级的递归建立
4. rmdir命令
	1. remove empty directories
	2. 只能删除空目录
	3. -p递归删除
	4. 并不推荐使用 太垃圾
5. rm命令
	1. rm -r 123 递归删除（询问）
		1. 进入到最深的空文件然后一级一级上级删除
	2. rm -rf 123
		1. 删除了目录本身
		2. 非常危险！
		3. 不会进入回收站
		4. 用的时候先想清楚 否则手快过大脑就gg
		5. 建议预先安装extundelete实现linux下文件和文件夹的数据恢复！！就算这样都不一定能恢复
	3. 如果不要删除当前目录，只删除当前目录下的所有子文件
		1. rm -rf 123/*
			1. 星号为通配符 可为任意内容


### 文件操作命令
1. touch命令
	1. change file timestamps
	2. 创建空文件或或修改文件的时间戳
2. stat命令
	1. status
	2. 显示文件或文件系统的详细信息
	3. 注意linux是不记录创建时间的
	4. 注意modify和change的区别
3. cat命令
	1. concatenate
	2. 查看文件内容
	3. -n显示行号
	4. -E列出每行结尾的回车符$
	5. -v列出特殊字符
	6. -T把tab用^I显示出来
	7. -A相当于 -vET 用于列出所有隐藏符
	8. 有些文件太大了 用cat不行 cat只适合看小文件
4. more命令
	1. 分屏显示文件的命令
	2. 用来显示cat无法显示的大文件
	3. 交互
		1. 空格 向下翻页
		2. b 向上翻页
		3. 回车 向下滚动一行
		4. /字符串 搜索制定字符串
		5. q 退出
5. less命令
	1. 分行显示文件的命令
	2. 交互
		1. 上下 一行一行翻
		2. q 退出
6. head命令
	1. 显示文件头	
	2. -n 行数：显示制定行数
	3. -f：监听 不会退出文件 如果其他终端往里写数据了 会继续显示新增内容 要用ctrl+c退出
7. tail命令
	1. 显示文件尾
	2. -n 行数：显示制定行数
8. ln命令
	1. link
	2. make links between files
	3. inode
		1. inode#
		2. 时间
		3. 权限
		4. block的位置
	4. block
		1. 储存了子文件的文件名和inode
	5. 所以如果我要查d文件的inode号， 我需要找到它的上级文件的block，在查询d的inode号...层层递归。所以要从根目录开始，根目录的inode号是固定为2（1在创建内核的时候被占用了）
	6. 硬链接
		1. 源文件和硬链接会拥有相同的inode和block
		2. 引用计数增加
		3. 修改其中一个 另一个都改变
		4. 删除任意一个文件 另一个都可用
		5. 硬链接标记不清，很难确认硬链接文件位置 不建议使用
		6. 硬链接 不能链接目录 因为链一个目录 所有子文件都要链 所以linux不让瞎搞
		7. 硬链接不能跨分区 俩文件要zhi xiang同一个分区的同一个inode
		8. 两东西其实是一个文件 只是名字不同而已 就像一个教室两个门 前门进人人数改变 后面进人人数也改变 堵上一个门 一样能进教室
	7. 软链接 ln -s
		1. 软链接和源文件拥有不同的Inode和Block
		2. 引用计数不会增加
		3. 任意修改一个 另一个都改变
		4. 删除软链接，源文件不受影响，删除源文件，软链接不能使用
		5. 软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接的大小不变
		6. 软链接的权限是最大权限lrwxrwxrwx，但是由于没有实际数据，最终访问时要参考源文件权限
		7. 软链接可以链接目录
		8. 也可以跨分区
		9. 软链接的标记特征明显 推荐使用
		10. 软链接移动要写绝对路径！！！！！否则很容易出错
		11. 其实可以理解成快捷方式 是为了照顾老手的使用习惯 因为很多升级改变了文件的位置 不好找

### 目录和文件都能操作的命令
1. rm命令
	1. -f：强制删除
	2. -i：交互删除 默认情况下就是
	3. -r：递归删除，可以删除目录
2. cp命令
	1. cp [选项] 源文件 目标文件
	2. copy
	3. -r递归复制 用于复制目录
	4. -a 相当于 -dpr 保证目标文件和源文件一模一样
	5. -d 如果源文件为软链接，则复制出的目标也为软链接
	6. -i 如果目标文件已经存在，则会询问是否覆盖
	7. -p 复制后目标文件保留源文件的属性，包括所有者 所属组 权限和时间
3. mv命令
	1. move
	2. 移动或重命名
	3. 移动目录不需要加-r
	4. mv 123 _tmp_ 把123这个文件或者目录原名移动到tmp文件下
	5. mv 123 234 把123重命名为234


### 基本权限管理
1. 权限介绍
	1. 带.的 表示受SELinux 保护的文件
	2. 共10项
		1. 文件的类型
			1. 具体类型 info ls查询
			2. 主要类型
				1. -：普通文件
				2. d：目录
				3. l：软链接
				4. 剩下的相对较常见的还有 b 块设备文件比如内存c 设备文件比如鼠标键盘 p 管道服务文件s 套接字文件 千万别动 例如可能导致要重装php或mysql
		2. 2-4 所有者权限
		3. 5-7 所属组权限
		4. 8-10 其他
		5. rwx分别代表读写执行权限
		6. 所有者权限优先于所属组权限
2. 基本权限命令
	1. chmod
	2. chmod [ugoa] [[+-=] [perm]]
		1. change file mode bits
		2. 赋予方式
			1. +
			2. -
			3. =
			4. 例子
				1. chmod u+x bcd 给bcd的所有者添加执行权限
				2. chmod g+w，o+w bcd
				3. chmod u-x，g-w，o-w bcd
				4. chmod u=rwx bcd
		3. 数字权限
			1. 4代表r
			2. 2代表w
			3. 1代表x
			4. 例子
				1. chmod 755 bcd
		4. 常用权限
			1. 644 基本权限
			2. 755 文件的执行权限和目录的基本权限
			3. 777 除了系统自带的 不允许手动赋予777 会造成安全隐患
				1. 有时候改了改了开源软件放进apache 报错权限不足，为了省事所以被改成了777，造成安全隐患
	3. chown命令
		1. change file owner and group
		2. chown [选项] 用户:所属组 文件或目录
			1. 也可用.分隔
		3. 注意：普通用户可以修改所有者是自己的文件的权限
		4. 注意：普通用户不能修改文件的所有者 哪怕是属于当前用户的文件 只有超级用户能修改所有者和所属组
		5. 测试
			1. 在root超级用户下
			2. 先添加用户 useradd user1
				1. 注意 添加用户就会自动添加进自动创建的同名组
			3. passwd user1
			4. 此处输入密码
			5. chown user1 bcd
	4. chgrp命令
		1. 修改所属组

3. 基本权限的作用（难点）
	1. 权限对文件的作用
		1. r：cat more less head tail等文件查看命令
		2. w：vim echo等修改文件数据的命令
			1. 注意：对文件有写权限 是不能删除文件的
			2. 如果想要删除文件，需要对文件的上级目录有写权限！原理是文件的原理 inode和block的内容，文件名和其对应的inode是存在于上级目录的block中的，而权限是针对inode所对应的block的，也就是说，对block的权限是储存在inode中的
		3. x：对文件来说执行权限是最高权限 也是风险最高的 代表该文件有了执行权限 是否能正确执行 不一定
	2. 权限对目录的作用
		1. r：ls
		2. w：touch rm cp mv等
			1. 对目录来说写是最高权限
		3. x：目录是不能执行的，但是如果目录拥有执行权限 对应到命令上就是可进入 可以执行cd命令
	3. 目录的可用权限
		1. 0:没有任何权限
		2. 5:基本的目录浏览和进入权限
		3. 7:完全权限
			1. 没有什么6权限 因为不能进入 拥有写权限没有意义
	4. 注意：权限对超级用户是没有意义的 不管怎么样实际都是777



### umask默认权限

1. 查看系统的umask权限
   - 默认用八进制数值显示umask的权限
     - 0022
     - 暂时我们忽略第一个数
     - 后面依次是022
     - 即
   - -S 用字母表示文件和目录的权限
2. umask权限的计算方法
   1. 新建文件的默认最大权限
      - 666
      - 执行权限对文件比较危险，不能在新建时默认赋予，必须用户手动赋予
   2. 新建目录的默认最大权限
      - 777
      - 执行权限就是进入目录，所以默认赋予
   3. 官方标准算法
      - umask需要使用二进制进行逻辑与和逻辑非联合运算得到正确的默认权限
        1. 将总权限（目录777 文件666）和umask转换为2进制
        2. 对umask取反
        3. 对两个值做与
        4. 转换为十进制即权限
      - 但我们可以这样理解
        - umask是我们希望从默认最大权限中去掉的权限
        - 如果本来有 则去掉
        - 如果本来就没有 维持原样
        - 所以 对文件来说 umask 033和022的结果都是644
   4. 注意
      - 要永久更改umask 要写入配置文件
        - /etc/profile
        - 环境变量配置文件
      - 否则都是暂时的更改



### 帮助命令

1. man命令
   1. manual
   2. man [命令]
   3. 快捷键
      1. 上下 移动一行
      2. PgUp PgDn 翻页
      3. g 第一页
      4. G/shift+g 最后一页
      5. q 退出
      6. /字符串 从当前向下搜索
      7. ？字符串 从当前向上搜索
      8. N 当搜索字符串时 使用N反向搜索
   4. 帮助级别
      1. 默认打开1级别 绝大部分命令只有1级别的
      2. 帮助级别
         1. 普通用户可以执行的系统命令和可执行文件的帮助
         2. 内核可以调用的函数和工具的帮助
         3. C语言函数的帮助
         4. 设备和特殊文件的帮助
         5. 配置文件的帮助
         6. 游戏的帮助
         7. 杂项的帮助
         8. 超级用户可执行的系统命令的帮助
         9. 内核的帮助
      3. man -f 命令 或者 whatis 命令
         - 查看命令拥有哪个级别的帮助
         - 小tip：新系统或者刚恢复快照 可能用whatis报错 可用makewhatis 解决
      4. man -k 命令 或者 apropos 命令
         - 查看命令相关的所有帮助
         - 只要包含命令的字符串都会被找到   不常用
2. info命令
   1. info命令比man更详细，是一套完整的资料
   2. 如果man找不到有用的信息，在用info
3. help命令
   1. 只能获取shell内置命令的帮助
   2. 作用很有限 一般不用
4. --help选项
   1. 绝大多数命令都可以使用--help选项来查看帮助
   2. 输出的帮助信息基本是man的简化版
   3. 例如 ls --help



### 搜索命令

1. whereis命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和帮助文档的位置

2. which命令

   1. 搜索命令的命令 不能搜索文件
   2. 搜索位置和灵命的别名

3. locate命令

   1. 按照文件名搜索普通文件的命令
   2. 优点：按照数据库搜索，速度快，消耗资源少，数据库位置/var/lib/mlocate/mlocate.db
   3. 缺点；只能按照文件名来搜索文件，不能执行更复杂的搜索
   4. 注意：搜索前先更新库 updatedb 否则刚产生的文件夹可能找不着
   5. 注意：配置文件里会排除一些文件和目录 例如tmp下的文件是搜不到的
   6. 常用

4. find命令

   1. 按照文件名搜索

      1. -name

         - find [路径] -name [文件名]

         - 严格区分大小写

      2. -iname

         - 不区分大小写

      3. -inum

         - 按照inode去搜索文件

   2. 按照文件大小搜索

      1. -size
         - find . -size -15
           - 默认单位b 512字节
           - c for byte
           - w for 2字节
           - k for KB
           - M for MB
           - G for GB
           - 大小之前- 代表小于

   3. 按照修改时间搜索

      1. -atime 访问时间
      2. -mtime 修改时间
      3. -ctime 状态修改时间
      4. 前三个时间单位为天
      5. -amin -mmin -cmin 以分钟为单位
      6. 格式：find . -atime +5
         - -5 五天内
         - 5 五到六天前的那24小时
         - +5 六天之前

   4. 按照权限来搜索

      1. -perm
         - 支持+—
         - +444 搜索包含444种任意一个组的权限的文件 三个数任意一个大于等于4
         - -444 搜索全部包含权限模式的文件 三个数全部大于等于4
         - 444 搜索搞好等于权限模式的文件

   5. 按照所有者和所属组搜索

      1. -uid
      2. -gid
      3. -user
      4. -group
      5. -nouser 查找没有所有者文件 即外来文件 如光盘和U盘等 否则一般是垃圾文件 常用来搜索垃圾文件

   6. 按照文件类型搜索

      1. find . -type d abc 查找目录
      2. -type f 普通文件
      3. -type l 软连接文件

   7. 逻辑运算符

      - find 搜索路径 选项 搜索内容

      1. -a 与
         - find . -size +2k -a -type f
      2. -o 或
      3. -not 或者!   非

   8. 其他选项

      1. -exec

         - find 搜索路径 选项 搜索内容 -exec 命令2 {} \;

         - 把find命令的结果交给由-exec调用的命令2来处理 {}就代表find命令的查找结果
         - find . -size +2k -a -type f -exec ls -lh {} \;
         - 注意命令2不支持别名

      2. -ok

         - 区别是每执行一次命令2 就询问一次
         - -exec就直接处理了
         - -ok 比-exec适合执行删除

5. grep命令

   1. 用于在文件中搜索符合条件的字符串
   2. 如果需要模糊搜索，使用正则表达式进行匹配
   3. 选项
      1. -i 忽略大小写
      2. -n 输出其在原始文件里的行号
      3. -v 取反
      4. --color=auto 搜索的字符串红色高亮

### 通配符

完全匹配

?匹配1个任意字符

*匹配任意个数任意字符 可以为0个字符

[] 匹配其中任何一个字符

[-] 表示范围

[^] 表示取反



### 正则表达式

用于包含匹配

? 匹配0或1个前一个字符 属于扩展正则符 需要egrep来识别

\* 匹配任意个数前一个字符

* "a*" meaningless since it can be any string

^ 限位符 匹配行首

$限位符 匹配行尾

正则一般用来粗过滤 因为文本处理快 占用资源小 支持访问量大 所以一般先用正则粗过滤 然后用程序过滤

#### 对比find和grep

1. find默认完全匹配 grep默认包含匹配
2. grep搜索的是字符串



### 管道符

1. 命令1 | 命令2
2. 命令1的争取输出作为命令2的操作对象
3. 为啥有了-exec还要管道符呢
   1. ｜是文本流操作
   2. find不支持文本流操作 所以不支持管道符
4. 例子
   1. ll /etc/ ｜ more
   2. ll /etc/ ｜ grep
      - 注意此处不能用find 因为grep才是搜索字符串的 更别说find不支持文本流
   3. netstat -tuln 查询系统中所有开启的端口
      1. netstat -tuln ｜ grep 80
         - 注意这个是包含匹配 是包含80的端口
   4. netstat -an 所有的端口号
      1. enstat -an | grep ESTABLISED | wc -l
      2. 统计正在连接的数量



### 命令的别名

1. alias 别名=' 命令'
2. alias grep=' grep --color=auto'
3. alias ser =' service network restart'
4. 注意！！ 别名的优先级比系统命令高，不要和系统命令重叠
5. 默认是临时的改变 永久更改需要写入配置文件~/bashrc
6. 注意！！**放在/etc/下的配置文件 对所有用户生效 放在家目录~/下的只对该用户生效*



### 常用快捷键

1. ctrl+a 光标移动到行首
2. ctrl+e 光标移动到行尾
3. Tab 命令或文件补全
4. ctrl+c 强制终止当前的命令
5. ctrl+l 相当于clear
6. ctrl+u 删除或剪切光标到行首的命令
7. ctrl+y 粘贴ctrl+u的内容



### 压缩和解压缩命令

- 系统无所谓扩展名 这是个管理员看的 因为不同格式的压缩命令不同

1. .zip
   1. windows下的压缩格式
   2. zip [选项] 压缩文件名 源文件名
      1. -r 压缩目录
      2. -d 解压缩
   3. unzip 文件名
      1. -d 制定解压缩位置
   4. 不常用
   
2. .gz
   - .gz较古老 压缩比低 占用资源少
   - bz2压缩比高 消耗资源多
   1. gzip
   2. gzip [选项] 源文件
      1. -c 将压缩数据输出到标准输出中，可以用于保留原文件
         - gzip -c abc >> abc.gz
         - 非常规操作
      2. -d 解压缩
      3. -r 压缩目录
         1. **不会打包**
            1. gzip -r abc
            2. abc目录下的每一个文件都压缩了 但是目录本身没有变
   3. gunzip 文件名
      - 解压缩

3. bz2

   1. bzip2
   2. bzip2 [选项] 源文件名
      1. -k 保留原文件
      2. -d 解压缩
      3. -v显示解压详细信息
   3. bunzip2 文件名
   4. **不能压缩目录**

4. .tar格式   **打包不会压缩**

   1. tar [选项] [-f 压缩包名] 源文件或目录
      1. -c 打包
      2. -f 制定压缩包文件名 压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名
      3. -v 显示打包文件过程
   2. tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg
   3. -x 解打包
      - 一般-xvf

5. **tar.gz 和 tar.bz2格式**

   1. tar [选项] 压缩包 源文件或目录
      1. -z 压缩和解压缩.tar.gz格式
      2. -j 压缩和解压缩.tar.bz2格式
   2. 所以 压缩 tar -zcvf 或者tar -jcvf
   3. 解压 tar-zxvf 或者tar -jxvf
   4. 只查看一下不解压 把c换成t就行了
   5. 解压缩到指定位置
      1. 解压缩的文件名后面 -C 解压路径
      2. tar -zxvf you.tar.gz -C abc/bcd
   6. 解压特定文件到指定位置
      1. tar -ztvf yui.tar.gz先看看里面有啥
      2. tar -zxvf yui.tar.gz -C /tmp test/cde
      3. 再解压其中的cde文件到/tmp中



### 关机和重启命令

1. sync数据同步
   1. flush file system buffers
   2. 刷新文件系统缓存
2. shutdown命令
   1. bring the system down
   2. -c 取消已经执行的shutdown命令
   3. -h 关机
   4. -r 重启
      - shutdown -r now
      - shutdown -r 05:30 最好不要在固定时间重启 比较危险 千分之几的几率存储设备出问题 不推荐让计算机自己执行 一般要有人看着
   5. 最安全的关机命令 会先保存各种东西再关
3. reboot命令
   1. 现在的系统中reboot也是安全的 而且不需要加入过多的选项
4. halt和poweroff
   1. 不推荐 不保存
5. init命令
   1. init是修改Linux运行级别的命令，也可以用于关机和重启，不建议使用



### 常用网络命令

1. 配置IP地址
   1. setup工具 （redhat系列专有）
   2. vi /etc/sysconfig/network-scripts/ifcfg-eth0    手工修改配置文件 主流方法
2. 重启网络服务
   - service network restart
3. 如果是虚拟机 需要侨界到有线网卡，并重启网络服务
4. 复制镜像有可能需要UUID（唯一识别符）
   1. 网卡配置文件里有
   2. 快照和当前系统UUID一样 或者 由于克隆虚拟机导致的UUID冲突
   3. vi /etc/sysconfig/network-scripts/ifcfg-eth0 删除MAC地址行
   4. rm -rf /etc/udev/rules.d/70-persistent-net.rules    删除MAC地址和UUID绑定文件
   5. reboot    重启Linux
   6. 此时UUID会重新计算 不可能像再相同

2. ifconfig命令
3. ping命令
   1. ping [选项] IP
      1. -c 指定ping的次数
      2. -b 探测整个网段 用于检测整个网段有多少台电脑
      3. -s 指定探测包的大小 感觉没啥用
4. netstat命令
   1. -a 列出所有网络状态 包括Socket程序
   2. -c 秒数：指定每隔几秒刷新一次网络状态
   3. -n：使用IP地址和端口号显示，不使用域名与服务名
   4. -t 显示使用TCP协议端口的连接状况
   5. -u 显示使用UDP.......
   6. -l 仅显示监听状态的连接
   7. -p 查看PID 看哪个程序占用了端口
      - netstat -tulnp
   8. -rn 可以查看网关
5. write命令
   1. 向其他用户发送信息
   2. w 看看谁在登陆中
   3. 登陆终端
      1. 本地字符终端tty1-6 使用快捷键alt+F1-6
      2. 本地图形终端 tty7 ctrl+alt+F7按住3秒 需要安装图形界面才有
      3. 远程终端 pts/0-255
   4. write 用户名 终端名
   5. 开始写sfsdfdg
   6. ctrl+d发送信息
6. wall命令
   1. 给所有人发送信息
7. mail命令
   1. 发邮件 mail 用户名
      1. mail 用户名
      2. 输入内容
   2. 查看mail
      1. 直接输入mail命令
      2. 输入标题号查看
      3. h键看标题
   3. 发送文件内容 常用
      1. mail -s “the subject” 用户名 /root/anaconda-ks.cfg
      2. -s "fsdfwe" 是邮件标题



### 系统痕迹命令

- 系统中的一些重要的痕迹日志文件，如/var/log/wtmp, /var/run/utmp, /var/log/btmp, /var/log/lastlog等日志文件，只能通过对应的命令查看，通过vim打开是乱码

1. w命令
   1. /var/run/utmp
   2. 第一行 系统时间 开机了多少时间 几个用户登陆中 系统前1分钟 5分钟 15分钟的平均负载
      1. 1分钟的负载超过核数 一般来说就是负载比较高了
      2. CPU和内存 70/90原则 cpu不要超过70%内存不要超过90%
   3. 第二行以后 用户名 终端名 IP 登陆时间 用户闲置时间 所有进程占用CPU时间 当前进程占用CPU时间 在干啥（-bash就是啥也没干 在等待）
2. who命令
   1. 也是看的w查看的日志
   2. 区别就是显示更简单
3. last命令
   1. 查看系统所有登陆过的用户信息
   2. /var/log/wtmp
4. lastlog命令
   1. 查看所有用户最后一次登陆的时间（包括系统用户）
   2. /var/log/lastlog
5. lastb命令
   1. 查看错误的登陆信息
   2. 比如密码输错了
   3. /var/log/btmp



### 挂载命令

1. mount命令基本格式

   - mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点

   1. linux所有储存设备都必须挂载
   2. 把设备名和一个空目录挂载
   3. mount
      1. 显示现在系统中挂载的设备
      2. 注意swap不用挂载 直接供内核访问
   4. mount -a 自动挂载 移动存储设备最好不要自动挂载 要是没插 会崩溃
      1. 命令会依据配置文件 /etc/fstab的内容 自动挂载
      2. 如果配置文件出错要修复 必须服务器现场
      3. 但现在来说 这个配置文件已经没有这么脆弱了 但是还是要非常注意
   5. -o里面都不建议修改 尤其是执行权限 容易有大问题 如果root所在分区不可执行 系统就崩溃了 无法启动

2. 光盘挂载

   1. mkdir /mnt/cdrom
   2. centOS6以后光盘设备名是/dev/sr0 以此类推
   3. 同时dev/cdrom是其软链接
   4. mount /dev/sr0 /mnt/cdrom
   5. 然后去挂载点访问光盘的内容
   6. 注意 一定记得卸载
      1. umount /dev/sr0
      2. 或者umount /mnt/cdrom都可以

3. U盘挂载

   1. fdisk -l   U盘跟硬盘共享设备名 所以不固定 要先查询
   2. 假设我们查到usb设备名为sdb1 格式为FAT32
   3. mount -t vfat /dev/sdb4 /mnt/usd/
   4. cd /mnt/usb/
   5. ls
   6. 发现中文都不能正常显示
      1. 要显示中文 首先要安装中文编码
      2. 终端要支持
      3. 注意本地终端不支持中文
      4. 但是远程终端是可以的
      5. 所以挂载时要手工指定中文编码
      6. mount -t vfat -o iocharset-utf8 /dev/sdb1 /mnt/usb/
      7. cd /mnt/usb/
      8. ls
      9. 这时应该可以了
   7. 用完卸载

4. 挂载NTFS分区 （默认不识别 就算挂载了 最多只读）

   1. Linux的驱动加载顺序
      1. 驱动直接放入内核中，这种主要是系统加载必须的驱动，数量较少
      2. 驱动以模块的形式放入硬盘，大多数驱动都用这种方式，保存位置是/lib/modules/kernel/      驱动模块是以.ko结尾的
      3. 驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载，如果加载需要重新编译内核，而NTFS文件系统的驱动就属于这种情况
      4. 硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则就要自己开发驱动了（笑）
   2. 使用NTFS-3G安装NTFS文件系统模块
      1. 后面学了安装再说



## vim编辑器

- vim是全屏幕纯文本编辑器，是vi编辑器的增强版

### vim基本使用

1. vim的工作模式
   1. 命令模式
      1. 用快捷键操作 无法写入
      2. ZZ 保存退出
      3. 插入命令
         1. a 追加 在光标坐在字符后插入
         2. i 插入 在光标坐在字符前插入
         3. A 光标所在行尾插入
         4. I 光标所在行首插入
         5. o 光标下插入新行
         6. O 光标上插入新行
   2. 输入模式
      1. 输入：进入编辑模式
   3. 编辑模式（末行模式）
      1. ：w 保存不退出
      2. ：w 新文件名   相当于另存为
      3. ：q不保存退出
      4. ：wq 保存退出
      5. ：！强制
      6. ：q！强制不保存退出，用于修改文件后不保存数据退出
      7. ：wq！强制保存退出，当**文件的所有者或者root用户**，对文件没有写入权限时候（比如000），强制写入数据使用

### 命令模式操作

1. 光标移动
   1. hjkl 左下上右
   2. 文件首尾
      1. gg 移动带文件头
      2. G 移动到文件尾
   3. 行首行尾
      1. ^ 移动到行首
      2. & 移动到行尾
   4. 移动到指定行
      1. :n 其中n是数字
2. 删除和剪切
   1. x 删除单个字母
   2. nx 删除n个字母
   3. dd 删除剪切单行
   4. ndd 删除剪切多行
   5. ：n1,n2d 删除指定范围 例如:3,5d
   6. p 粘贴到光标后
   7. P 粘贴到光标前
   8. dG从光标所在行删除到文件尾
   9. yy 复制单行
   10. nyy复制多行
   11. u 撤销
   12. ctrl+r 反撤销
   13. r 替换光标所在处字符
   14. R 从光标所在处开始替换字符，按ESC结束

### 末行模式

1. vim 配置文件 ~/.vimrc
   1. ：set all 进行查看
   2. ：set nu   ：set nonu   显示与取消行号
   3. ：syntax on   ：syntax off   是否根据语法显示相关颜色的帮助
   4. ：set hlsearch  ：set nohlsearch   是否将查找的字符串高亮显示
   5. ：set ruler   ：set noruler   是否显示右下角状态栏
   6. ：set showmode   ：set noshowmode   是否左下角显示模式状态栏
   7. ：set list   ：set nolist  是否显示隐藏字符   tab是^I 回车是$

### 查找

- /查找内容   从光标所在行向下查找
- ?查找内容   从光标坐在行向上搜索
- n 下一个
- N 上一个

### 替换

- ：1，10s/old/new/g   替换1到10行所有old为new
  - s代表替换
  - g代表替换所有
- ：%s/old/new/g   替换整个文件的old为new
  - %是个变量 这里代表整篇文档
- ：1，10s/^ /#/g 注释1到10行
- ：1，10/^#//g 取消注释
- ：1，10/^\/\//g 1到10行 行首加入//
  1. 或者 按esc进入命令模式
  2. ctrl+v
  3. 上下移动选取
  4. shift+i and type
  5. esc

### vim使用技巧

1. 在vim中导入其他文件内容或命令结果
   1. ：r 文件名
      * 把文件内容导入光标位置
2. 在vim中执行系统命令
   1. ：！命令
      - 暂时跳出vim执行一次系统命令
3. 导入命令结果
   1. ：r !命令
4. 设定快捷键
   1. ：map 快捷键 快捷键执行的命令
   2. ：map ^P I#\<ESC\>   按ctrl+p在行首加入注释
   3. ：map ^B ^x    按ctrl+b 删除行首第一个字母
      - 注意 ^ 使用 ctrl+v输入的 普通的^并不起作用
   4. 要永久生效 写入~/.vimrc
5. 字符替换
   1. ：ab 原字符 替换为字符
      - 在vim编辑中 有时需要频繁输入长字符串 例如邮箱 我们可以用另一个字符串代替 每次输入源字符 自动变
6. 多文件打开
   1. vim -o abc bcd
      - 上下分屏打开两个文件
      - ctrl+w 再按方向键 在文件之间跳转
      - 如果要左右分屏 则-O



## 软件包安装

### 软件包分类

- 源码包
- 二进制包

1. 源码包
   1. 开源 可以自己动手改
   2. 自由选择所需功能
   3. 软件是便衣安装，更加舍和自己的系统，稳定，效率高
   4. 卸载方便
   5. 安装过程步骤较多，尤其安装较大软件合集时，容易出现拼写错误
   6. 编译时间长，比二进制安装时间长
   7. 因为是编译安装，安装过程中一旦报错新手很难解决
2. 二进制包
   1. DPKG包 一般叫Deb包 因为由Debian开发
   2. RPM包 由Red Hat开发
   3. 简单 命令实现安装升级查询卸载
   4. 功能选择不灵活
   5. 依赖性
   6. 看不到源代码
3. 软件包选择建议
   1. 源码包：如果服务是给大量客户端提供访问的，建议使用源码包，源码包效率更高
   2. RPM包：如果程序是给少量用户访问，或者本地使用的，建议RPM包，因为RPM管理

### 依赖性

1. 树形依赖
   - a --> b --> c
2. 环形依赖
   - a --> b --> c --> a
   - 解决办法 同时安装
3. 模块依赖
   1. 很多时候 缺的库根本不知道从哪找
   2. 还好现在我们有网站 www.rpmfind.net
   3. 不过我们现在有两种安装方式
      1. 手工安装
      2. yum安装 是一种链接redhat的在线安装

### rpm

1. rpm包命名规则
2. 以阿帕奇为例：httpd-2.2.15-15.e16.centos.1.i686.rpm
   1. 进程名 版本 发布次数 适合的平台 硬件平台 
   2. 包全名：如果操作的是为安装软件包，则使用包全名，且用绝对路径
   3. 包名：如果操作的是已经安装的软件包，系统会产生数据库/var/lib/rpm/   所以使用包就行了 而且在任意路径下都行
3. 安装命令
   1. rpm -ivh 绝对路径下包全名
      1. 然后根据依赖层层安装
      2. 建议不要给rmp安装在指定路径 就默认就好了 作者觉的哪好就在哪 还有一个原因是service命令是在固定位置搜索的
      3. 另外rmp包管理系统是有卸载命令的 数据库记录安装位置 不怕装得这一个那一个 源码包则不行 必须手动选择安装路径否则很难卸载
      4. 如果非要重新定义安装路径 在整个命令后面 --prefix=/dsf/dfd/sd/
   2. --nodeps 不检测依赖性安装 不建议
   3. --force 强制安装 不管安没安过 如果不消息误删了部分文件 可以用这种方法
   4. --test 不会安装 检测一下依赖性
4. 启动命令
   1. service可以启动大部分的rpm包
      1. service httpd start 也可以restart和stop和status
      2. /etc/rc.d/init.d/httpd start 更标准 注意这个目录下的阿帕奇是通过软链接启动的
      3. 其实service就是搜索的这个目录启动服务的
      4. 注意阿帕奇中的网页文件 在/var/www/html/
      5. 写完网页之后就好了 如果没有修改配置文件 是不需要重启阿帕奇的
      6. 阿帕奇的配置文在/etc/httpd/conf/httpd.conf
5. rpm包升级
   1. rpm -Uvh 包全名
      - -U 升级安装 如果没有安装过 直接安装
      - -F 必须有旧版本才能升级安装
6. rpm卸载
   1. rpm -e 包名
      - -e 卸载
      - --nodeps 不检查依赖 不推荐
   2. 按照安装顺序倒序卸载
   3. 注意不要用yum卸载 因为yum卸载不检查除卸载程序以外的依赖 而且也不知道包名 有可能装不回来
7. 查询（yum无法取代）
   1. rpm -q 包名
      1. 查询的是客户端
      2. yum查的是服务器端的
   2. -a 所有
      1. 我们可以利用grep查询所需的
      2. rpm -qa ｜ wc -l
      3. rpm -qa ｜ grep httpd
   3. rpm -qi 包名
      1. -i 软件包说明
   4. rpm -qip 包全名
      1. 查询未安装包的信息
   5. rpm -ql 包名
      1. 确认软件包的安装位置和完整的目录信息
   6. rpm -qlp 包全名
      1. 查询未安装包打算装在哪
   7. rpm -qf 系统文件名
      1. 查询系统文件属于哪个软件包
   8. rpm -qR 包名
      1. 查询依赖包 没啥用 装没装无法知道
8. 验证
   1. rpm -V 已安装包名
      1. 校验已安装的文件
      2. 查询结果
         1. S：文件大小是否改变
         2. M：文件的雷总或文件的权限（rwx）是否改变
         3. 5：MD5完整性校验 可理解成文件内容是否改变
         4. D：设备的主从代码是否改变
         5. L：文件路径
         6. U：文件所有者
         7. G：文件所属组
         8. T：修改时间
         9. 文件类型（以apache为例）
            1. c 配置文件 config file
            2. d 普通文档
            3. g 鬼文件 很少见 就是该文件不应该属于这个rpm包
            4. l 授权文件 license file
            5. r 描述文件 readme
      3. 这个校验是和包里面的原始值做对比的 但如果原始值被改了呢？ 答案是数字证书！从官网那里导入数字证书 保证原始值是符合官方验证的 是原厂包
         1. rpm -qa ｜ grep gpg 查询相应的数字证书 此处我们看的数字证书是包含GPG的 如果结果error 就是没导入
         2. rpm --import 包名
         3. 再查一遍看看
         4. 记住 重要度非常高！！！
   2. rpm -Vf 系统文件
9. rpm包中文件提取命令
   1. 如果我们不是误删除文件 而是误修改了 这时候强制覆盖安装没用 它只会清空配置内容 不会修改已存在的文件的内容
      1. 注意 平常修改服务器文件 修改之前要备份 就放在同样的目录下 加个标记就行了 比如后缀.bak
      2. cpio命令（太复杂 不用）
         1. cpio -o [vcB] > [文件｜备份]
         2. cpio -i [vcdu] < [文件｜备份]
      3. cp命令 （不用 cp只能拷贝到同一个硬盘 不能把鸡蛋放在同一个篮子里）
   2. rpm2cpio 包全名 ｜ cpio -idv .加上文件绝对路径
      1. rpm2cpio 将rpm包转换为cpio格式的命令
10. rpm包在线安装（yum安装）
    1. yum源  文件解析
    2. [搭建本地yum源](https://www.bilibili.com/video/BV1ut411a7ro?p=61)
    3. yum命令
       1. 查询（查询的是服务器并不是当前客户端 不能替代rmp的查询）
          1. yum list 列出所有可用软件包 可用于区分来自哪个yum源
          2. yum list 包名
          3. yum search 关键字
          4. yum info 包名
       2. 安装
          1. yum -y install 包名   注意yum不用区分包名包全名 因为yum源包含了相关信息
             1. -y 自动回答yes
             2. 自动解决依赖问题
       3. 升级
          1. yum -y update 包名
          2. yum -y update      这个是升级本机所有软件包 包含内核 一般不用 否则可能有重大系统隐患 centOS5之前是禁止的
       4. 卸载
          1. yum remove 包名
             1. 不要用 无视依赖强行卸载包及其依赖链
             2. 老手 并熟悉包才用
11. yum组管理命令
    1. 很多情况下我们无法知道包名 比如由于语言的问题
    2. yum grouplist   查询已安装的组
    3. yum groupinfo 软件组名
    4. yum groupinstall 组名
    5. yum groupremove 组名



### 源码包

- 必须指定安装位置 除非有些指定了位置会导致后续安装包找不到其位置报错

1. 安装

   1. 下载
   2. 解压
   3. 进入解压目录
   4. ./configure --prefix=安装地址  编译前准备   现在有些变成cmake了
      1. 作用1: 检测系统环境
      2. 作用2：自定义功能选项
      3. 作用3: 把前两个的结果写入Makefile文件 后续的操作都依靠这个文件
   5. make   编译   注意4和5是不会写入文件的 如果报错 解决后 只要用make clean 清除临时文件就行了
   6. 源码包报错：
      1. 安装过程停止
      2. 出现了错误关键词
      3. 解决问题
      4. make clean：清空编译内容
   7. make install 编译安装
      1. 此时如果报错 之前的安装过程是有写入的！
   8. 注意要看安装文档INSTALL 看看各种文件安装到哪了

2. 打补丁

   1. 补丁的生成（很少见了）

      1. diff 选项 old new

         - diff -Naur 绝对路径 绝对路径 > txt.patch

         1. 比较old和new文件的不同
         2. -a 将任何文档当作文本文档处理
         3. -b 忽略空白造成的不同
         4. 。。。等等 看文档吧

   2. 打入补丁

   3. patch -pn < 补丁文件

      1. [具体n写几 参见视频8分钟左右](https://www.bilibili.com/video/BV1ut411a7ro?p=66)

3. 删除

   1. 源码包没有删除 直接删除安装目录即可



### 脚本安装包

- 用一个脚本封装安装过程
  - 优点：快
  - 缺点：版本 功能 安装位置等都得听作者的
- 案例：Webmin安装
  - 用浏览器来管理Linux
  - 下载
  - 放入Linux
  - 解压缩
  - 进入目录
  - ./setup.sh
  - 完事
  - 怎么访问？浏览器属通过p：端口访问



## 用户管理

- 防内大于防外 权限划分防患于未然

### 用户相关文件

1. /etc/passwd   用户信息文件
   1. 每一行都是一个用户 大部分都是系统用户 用来启动相应的服务
   2. 有7列
      1. 用户名
      2. 密码标识 x代表有密码
         1. 用户名在etc/shadow中加密后显示了
         2. 如果没x标志 系统就不会要求密码
      3. 用户ID 
         1. 0 是超级用户UID
            1. 如果把普通用户的UID改为0 就成了root   一般情况下不要弄俩root
         2. 1-499 系统用户UID也就是伪用户 所有安装的软件都会需要一个为用户启动相应的服务 （65534也是 匿名用户）
         3. 500-2^32 普通用户UID
      4. 组ID
         1. 具体是啥要去查/etc/group
      5. 说明
      6. 家目录
      7. 登陆shell   也就是权限   普通用户是/bin/bash
         1. 伪用户都是/sbin/nologin
2. /etc/shadow   影子文件
   1. 9 列
      1. 用户名称
      2. 用户密码（SHA512加密）
         1. 伪用户都是*或者！！
         2. 如果想让一个用户暂时不能登陆 在密码前面加个！
      3. 更新密码的时间
         1. 时间戳 1770.1.1开始算 +天数
         2. echo $(($(date --date="2020/08/01" +%s)/86400+1))
      4. 限制两次密码修改的间隔时间 跟3相比
      5. 密码有效期 默认99999 也是跟3比的
      6. 密码到期前的警报天数 和5相比
      7. 密码到期之后的宽限天数 跟5相比 默认-1 意思是无限宽限
      8. 密码的失效时间
         1. 比如会员有效期 过了就到期了
         2. 也是写的时间戳 到了这个时间就失效了 失效了会在密码段加1个！
3. /etc/group   组信息文件
   1. 4列
      1. 组名
      2. 组密码位
         1. 在/etc/gshadow
         2. 并不推荐
         3. 是用来管理组的
         4. 踢人 加人 是有管理风险的 一般不推荐下放
      3. GID
      4. 附加组
         1. 除了初始组（只能且必须有一个）以外的组
         2. 所以只建议改附加组 不建议改初始组
         3. 因为改了之后忘了不好查 这不显示
4. 用户的家目录
5. 用户的邮箱目录
   1. /var/spool/mail/用户名
6. 用户模版目录
   1. /etc/skel/
   2. 生成的用户都会拷一份放在新用户的家用户里
   3. 可以用来给新用户写警告文档或者操作规范等



### 用户管理命令

1. 添加用户
   1. 本质就是添加信息到下列文件
      1. /etc/passwd
      2. /etc/shadow
      3. /etc/group
      4. /etc/gshadow
      5. /home/用户名
      6. /var/spool/mail/用户名
   2. useradd命令
      1. useradd 选项 命令
         1. -u 550 指定UID
         2. -g 组名 指定初始组
            1. useradd -g t1 p1
            2. 此时p1的初始组是t1组
            3. p1组是没有建立的
            4. t1组还会是t1的初始组 当然目前t1可能还没建立
            5. 非常混乱 不推荐！
         3. -G 组名  指定附加组
         4. -c 说明 添加说明
         5. -d 目录 手工指定家目录 不需要事先建立
         6. -s shell   /bin/bash
      2. /etc/default/useradd 和 /etc/login.defs
2. 设置密码
   1. 对于超级用户
      1. passwd 选项 用户名
         1. -l 暂时锁定用户
         2. -u 解锁用户
         3. --stdin 可以通过管道符输出数据作为用户密码 主要在批量添加用户时使用
            1. 记得history -c 否则相当于明文存在了历史记录里
         4. chage -d 0 用户名
            1. 把时间戳改成0
            2. 登陆就会让该用户改密码
   2. 对于普通用户
      1. passwd
3. 用户信息修改
   1. usermod命令 时修改已添加的用户
      1. -G 修改附加组
      2. -L 所用户
      3. -U 解锁
      4. 一般不改用户名 容易晕菜 建议删了 再建
4. 用户删除
   1. userdel -r 用户名
      1. 不会删除家目录 成为了垃圾文件
      2. 所以-r是必备的
5. 切换用户登陆
   1. su - 用户名
      1. 注意使用一些命令 仍会显示切换前的信息
      2. 中间必须加减号 代表家目录也切换了



### 用户组管理

1. 组添加

   1. groupadd
   
2. 组删除

   1. groupdel 注意 作为用户的初始组的组没法删除 必须先改变其状态

3. 组内添加删除用户

   1. gpasswd -a 用户 组名   加入组
   2. gpasswd -d 用户 组名   踢出组
   3. 一般这个比较常用 而不是usermod

4. 改变有效组

   - 所谓有效组 就是新建文件之后的默认所属组 注意用户必须拥有超过一个所属组才能改变有效组

   1. newgrp 组名

5. 组权限实验

   1. 分配权限的时候要先搞清身份 再分配权限



## 权限管理

### ACL权限

1. 概述

   1. 用于解决用户对文件身份不足
   2. 直接让用户对特定文件或者目录有权限

2. 开启ACL

   1. dumpe2fs -h /dev/需要查询的分区

   2. 如果没有开启 手工开启

      mount -o remount，acl /

      重新挂载分区 并挂载加入acl权限

   3. 也可以通过修改/etc/fstab文件永久开启ACL文件
      vi /etc/fstab

      编辑完mount -o remount /

3. ACL基本命令

   1. getfacl 文件名 查询ACL的权限

   2. setfacl -m u：用户名：权限 文件名

      setfacl -m g：用户名：权限 文件名

   3. -m 设定acl权限

   4. -b 删除acl权限

   5. -x：用户   删除某用户的acl权限

   6. -R 递归  只能用于目录  **对以前建立的文件生效**

      setfcal u：user4:5 -R /www/
      1. 但是之后新建的文件不满足acl权限
      2. 这时候加一个d **对以后新建的文件生效**
      3. setfcal d：u：user4：5 -R /www/

   7. **注意  ACL权限递归之后 很容易出现权限溢出 因为文件的执行文件是很危险的 但是目录的执行权限是必须的 如果你对目录递归了 之后的目录下的文件都有了执行权限   必须用脚本实现区分文件和目录的权限赋予！！！**

   8. 最大有效权限mask

      1. mask权限是能赋予acl权限的上线
      2. 两个权限做与才是真正的权限
      3. 默认是rwx 建议默认就好了

   9. 删除ACL权限

      1. setfacl -x u：用户名  文件或目录名
         1. 删除置顶用户或用户组的acl权限
      2. setfacl -b 文件或目录名
         1. 删除文件或目录的所有acl权限



### sudo授权

- 给普通用户赋予部分管理员权限
- /sbin/和/usr/sbin/目录下只有超级用户才能使用

1. 赋予的权限越详细，普通用户得到的权限越小
2. 在root身份下 visudo
   1. 用户名 ALL=/sbin/shutdown -r now
   2. 格式其实是 用户名 被管理主机的地址=（可使用的身份） 授权命令（注意是绝对路径）
3. 回到对应用户
   1. sudo -l 查询啥命令可以sudo
   2. 然后 sudo /sbin/shutdown -r now
4. 举例：我想授权一个用户管理我的web服务器 可以使用apache管理脚本 可以修改apache配置文件 可以更新网页内容
   1.  visudo
   2. user1 192.168.0.156=/etc/rc.d/init/httpd reload, /etc/rc.d/init.d/httpd configtest
5. 举例：授权aa用户可以添加其他普通用户
   1.  visudo
   2. aa ALL=/usr/sbin/useradd
   3. aa ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd "", !/usr/bin/passwd root



### 文件特殊权限 SetUID，SetGID，Sticky BIT

- 前两个非常危险 禁止手动赋予
- 对应数字4，2，1

1. ​    SetUID
   1. 只有可以执行的二进制文程序才能赋予SetUID
   2. 命令执行者要对该程序拥有执行
      1. passwd这个命令其实是有SetUID的 因为它实际上写入了管理密码的shadow文件 但这个文件本应是root才能写的
   3. 命令执行者在执行该程序时获得该程序文件属主的身份
   4. SetUID权限仅仅在该程序的执行过程中有效，也就是说身份改变只在程序执行的过程中有效
      1. 建议
         对系统中默认的应该具有的SetUID列一个列表，定时检查有没有这之外的文件被设置成了SetUID权限
      2. 检测SeUID的脚本
2. SetGID
   1. 针对文件的作用 和SetUID相似
      1. 唯一的区别是执行过程中会变成相应的所属组
      2. 同样高风险
   2. 针对目录的作用 无风险
      1.  没啥太大的作用
      2. 如果执行者对该目录拥有7的权限（这个本身就挺有风险。。。others的权限是7。。。）
      3. 新建了文件之后 文件的所属组是文件本来的所属组 而不是执行者的所属组
      4. 可能在容器里还有用
3. StickyBIT
   1. 本身没啥风险 但是跟上面那个一样 风险在于文件的权限需要777
   2. 就算普通用户对该目录有7的权限 也只能删自己的文件 不能删除其他人的文件



### chattr权限

- 是可以限制root的

1. 命令格式
   1. chattr [+-=] 选项 文件或目录
   2. i 如果文件则所有的操作都锁了 如果是目录则目录下的文件可以改
   3. a 文件：能增加数据 不能删除 不能修改。 目录：能新建和修改 不能删
2. lsattr 文件
   1. 查看chattr权限
   2. 查看目录要加-d ！！！！
   3. 很容易忘 因为ls是看不出来的



## 文件系统管理

### 硬盘结构

1. 硬盘逻辑机构
   1. 每个扇区大小是固定的 512B 是磁盘的最小存储单位
2.  接口
   1. IDE
   2. SATA
   3. PCI-E



### 文件系统

1. Linux文件系统特性
   1. super block
   2. group
   3. block
2. 常见文件系统
   1. ext4
   2. xfs 安全性更好 不容易丢数据 大文件读写更好
3. 常用的硬盘管理命令
   1. df命令
      1. 统计分区大小
      2. df -ahT
      3. 显示特殊文件 人性化显示 显示文件类型
      4. 一般就用-h
   2. du命令
      1. du 选项 目录或文件名
         1. -a 显示每个子文件的磁盘占用 而不是默认的仅显示子目录
         2. -h 人性化显示
         3. -s 统计总占用量 不列出子目录和子文件的占用量
      2. ls统计的目录大小是不准确的 他统计的是保存子文件的文件名和inode的地方的大小 所以大部分的大小都是4k的倍数 这是由于分区的block大小决定的
      3. du -h 目录 和df -sh 目录 统计的大小是不一样的
         1. 区别是因为太久没重启 临时文件和垃圾文件没有释放
         2. du是统计文件大小，统计的文件大小是准确的
         3. df是统计空间大小 统计的剩余空间是准确的
   3. fsck 文件系统修复命令
      1. 开机自动的 一般不用
   4. 显示磁盘状态 dumpe2fs
      1. dumpe2fs /dev/sda3
   5. stat 文件名 查看文件的详细时间
   6. 判断文件类型
      1. file 文件名
      2. type 命令名
4. **手动分区**
   1. fdisk -l
      1. 查看分区
   2. fdisk /deb/sdb
   3. 输入m查看帮助
   4. n 新建分区
      1. 分区号
      2. p主分区
         1. first cylinder起始柱面 1
         2. last cylinder终止柱面 +20G
      3. e扩展分区
   5.   p 查看分区
   6. w保存退出
5. 格式化
   1. mkfs -t ext4 /dev/sdb1
   2. 注意扩展分区无法格式化 只能格式化主分区和逻辑分区
6. 建立挂载点
   1. mkdir /disk1
   2. mount /disk1 /dev/sdb1
7. 查看
   1. mount 查看所有已挂载分区和光盘
   2. fdisk -l 查看系统分区
   3. df 查看分区占用百分比
8. 自动挂载
   1. 修改分区自动挂载文件
   2. vi/etc/fstab 注意此文件直接参与系统启动，如果修改错误，系统启动报错
   3. 6列
      1. 分区文件名 或者UUID号
         1. 最好是UUID号，因为比如老硬盘坏了 换了个新的但是挂载的名字一样 会报错 但UUID是唯一的，换了盘也能区别
         2. 查看UUID的方法
            1. dumpe2fs /dev/sdb5
            2. ls -l /dev/disk/by-uuid/
      2. 挂载点
      3. 文件系统
      4. 挂载选项
      5. 1 是否可以被备份 0不备份 1每天备份 2不定期备份
      6. 2 是否检测磁盘fsck 0不检测 1启动时检测 2启动后检测
         1. 建议只有根分区启动时检测 其他2 否则启动很慢
9. 重启测试 mount -a 或者 reboot
10. /etc/fstab 文件修复
    1. 前提是要拿到本机
    2. 远程无法修复
    3. 由于启动未成功 网卡没生效 而且分区也只是只读挂载
    4. 必须 mount -o remount，rw /
    5. vi etc/fstab
    6. 修改保存退出
    7. reboot
11. **parted** **命令分区**
    1. ：Linux有两种常见的分区表（主引导记录分区表）和GPT分区表（GUID分区表）
       1. MBR分区表：支持的最大分区是2TB 最多支持4个主分区 或者3主分区1扩展分区
       2. GPT分区表：最大支持18EB的分区，支持128分区 其中一个系统保留分区 127个用户自定义分区
    2. 注意 **一定要把etc/fstab 自动挂载里面的相应的硬盘删了 否则重启会报错**
    3. 分区：parted 交互模式
       1. 修改etc/fstab
       2. parted /dev/sdb
       3. help获取命令
       4. print 打印列表
          1. 其中msdos就是MBR分区
       5. 修改成GPT分区
          1. mklabel gpt
       6. print
          1. 分区消失
          2. 这就是为什么要修改那个表
       7. quit
       8. reboot
       9. parted /dev/sdb
       10. mkpart 建立分区
           1. 名字 disk1 用来区分的 没啥用
           2. 系统类型 只能ext2 
           3. 大小
       11. 格式化 mkfs （注意这个是parted交互内的）
       12. quit
       13. 要格式化ext4文件系统 要用linux的mkfs
           1. mkfs -t ext4 /dev/sdb1 
       14. 挂载
           1. mount /dev/sdb1 /disk1/
       15. 修改自动挂载文件
       16. 测试重启
       17. 如果要调整大小
       18. 卸载分区 umount
       19. resize命令 不常用 因为可以用LVM
    4. **swap分区**
       1. free -h   查内存 能看到swap 是作为内存的缓冲的
          1. buffer是用来提高写入速度的
          2. cache 是用来提高读取速度的
       2. 分区 并修改swap ID
          1. fdisk /dev/sdb
          2. n
             1. p
          3. t 修改ID
             1. 选择分区
             2. 82
          4. 格式化
             1. mkswap /dev/sdb1
          5. free -h
          6. swapon /dev/sdb1
             1. 这时暂时生效的
             2. 要修改/etc/fstab
                1. /dev/sdb1 swap swap defaults 0 0
          7. 测试重启



## 高级文件系统管理

### 磁盘配额

1. 概念
2. 条件
   1. 内核支持
      1. grep CONFIG_QUOTA /boot/config-2.6...........
   2. 安装了quota包
      1. rpm -qa ｜ grep quota
3. 概念
   1. 用户配额和组配额
      1. 组配额几乎没有可用性 因为组配额是先到先得的 可能头几个用户全用完了
      2. 磁盘容量限制和文件个数限制
         1. 因为空间和inode数量都是有上限的
      3. 软限制和硬限制
         1. 软限制是发出警告
         2. 硬限制就不能用了
      4. 宽限时间
         1. 超过软限制之后 超过宽限时间之后 变为硬限制
         2. 默认7天
4. 磁盘配额规划实验
   1. 首先规划出一个分区
   2. 建立被限制的用户和用户组
      1. 假设需要限制user1，user2，user3用户
      2. 组就算了 不怎么使用
   3. user1 50MB 40MB 无限
      1. useradd user1
      2. passwd user1
      3. 输入密码
      4. mount -o remount，usrquota，grpquota /disk
         1. 在分区上开启磁盘配额功能
         2. 想要永久生效 需要修改/etc/fstab
            1. vi /etc/fstab
            2. /dev/sdb1 /disk ext4 default，usrquota，grpquota 0 0
            3. 此种方式需要重启生效
            4. 先用4临时生效 在改 可以先临时生效 重启后也会永久生效
      5. quotacheck 选项 分区名 生成磁盘配额  
         1. 需要关闭**SELinux** 否则报错
            1. getenforce
            2. setenforce 0
            3. getenforce
            4. 临时关闭
            5. 永久生效还得改配置文件/etc/selinux/config
         2. quotacheck -avu 
            1. 如果是根分区还要加个m选项 强制
            2. 因为根分区正在使用中
      6. edeuota 选项 用户名   设置配额限制
         1. -u设置用户配额
            1. 前三项是block的限制 是大小
            2. 后三项是inode的限制 为文件数量的限制
            3. 注意 **block和inodes不能改** 
      7. quotaon 选项 分区名  启动用户配额
         1. -avu 自动 显示过程 开启用户配额
      8. quota 选项 用户  查询用户配额
         1. -uvs 用户 详细显示 人性化显示
      9. repquota -avus 查分区的
      10. 用user1测试
          1. cd /disk/
          2. dd if=/dev/zero of=/disk/testfile bs=1M count=60
             1. 建立testfile 往目标目录写入60个1M文件 直到写完或写满
   4. 磁盘配额的其他命令
      1. 复制命令
         1. edquota -p user1 -u user2
            1. 将user1的配额复制到user2
         2. 非交互设定用户磁盘配额
            1. setquota -u 用户 软限制 硬限制 个数软限制 个数硬限制 /disk/
            2. 这个适合写脚本 因为不需要进入edquota交互界面
   5. 更改宽限时间
      1. edquota -t

### LVM逻辑卷管理

1. 简介
   1. 与sda1 sda2这种传统主分区不同 逻辑分区可以动态调整大小
   2. 如果硬盘不够了 还能把新的加入进去
   3. 实际工作中 至少也是LVM
2. 物理卷 PV：真正的物理硬盘或分区
3. 卷组 VG：多个物理卷的组合，可以来自于一块硬盘，也可以来自其他
4. 逻辑卷 LV：卷组是一个逻辑硬盘，硬盘必须分区才能使用，这个分区我们称做逻辑卷
5. 物理扩展 PE：最小单位是4MB 是逻辑卷的最小单位 但它不是block 最后还要格式化成block
6. 建立LVM的步骤
   1. 硬盘分区 把ID号改成8e
      1. 具体操作往回看
   2. 建立物理卷
      1. pvcreate /dev/sdb5
      2. pvcreate /dev/sdb6
      3. pvcreate /dev/sdb7
      4. pvscan
      5. pvdisplay 查看
   3. 建立卷组
      1. vgcreate vg /dev/sdb5 /dev/sdb6
   4. 添加物理卷
      1. vgextend vg /dev/sdb7
   5. 添加逻辑卷
      1. 建立逻辑卷
         1. lvcreate 选项 -n 逻辑卷名 卷组名
            1. -L 容量   指定逻辑卷大小
            2. lvcreate -L 3G -n userlv vg
         2. 格式化和挂载
            1. mkfs -t ext4 /dev/vg/userlv
            2. mkdir /disklvm
            3. mount /dev/vg/userlv /disklvm/
         3. 查看
            1. lvdisplay
         4. 调整逻辑卷大小
            1. lvresize 选项 逻辑卷设备文件名
               1. -L 容量：安装容量调整大小 
               2. lvresize -L 4G /dev/vg/userlv
               3. 把userlv调整到4G
               4. 然后我们要让分区知道大小变化了 所以把整个逻辑卷都加入到/disklvm分区
                  1. 所以我们有调整分区大小的命令 这就是LVM的优势
                     1. resize2fs 选项 设备文件名 调整的大小
                        1. 设备文件名：指定调整哪个分区的大小
                        2. 调整的大小：指定把分区调整到多大 要加M G等单位 如果不加大小，会使用整个分区
                  2. resize2fs /dev/vg/userlv 把整个调整过的逻辑卷加入到分区中
         5. 完事 不需要重新挂载或重启

### Raid



## shell基础

### shell概述

- 硬件 --> 内核 --> shell命令解释器 --> 外层应用程序
- Bourne Again（Bash）zsh也属于这个家族
- POSIX Shell（psh）

### 脚本的执行

1. echo命令
   1. echo 选项 输出内容
      1. -n 取消输出后的换行
      2. -e 支持转义字符
         1. 具体的转义表 google
         2. echo -e "\e[1;31m abcd \e[0m"
2. 脚本的开头要写出所用的shell
   1. #!/bin/bash
3. 绝对路径执行或相对路径
   1. 或者 bash hello.sh



### Bash的基本功能

1. 历史命令

   1. history
   2. 每次退出之后写在了家目录下。bash_history
   3. -c 清空 不建议使用 这个对于查错很有用 一般只有暴露密码的情况下才清空 比如mysql密码明文保存了
   4. -w 把缓存中的卸乳历史命令保存文件
   5. 历史文件条数存在/etc/profile
      1. 默认1000条
      2. 这个是放在硬盘而不是内存 可以多调点
   6. ！！执行上一条命令
   7. 其他的不常用 想看可以查

2. source命令

   1. . 就是source命令
   2. 作用是不用重新登陆 就让更新的配置文件生效
      1. source ~/.Bashrc
      2. . ~/.Bashrc

3. 命令执行的优先级

   1. 用绝对路径或相对路径执行的命令
   2. 别名
   3. Bash内部命令
   4. 按照$PATH环境变量定义的目录查找顺序找到的第一个命令

4. Bash常用快捷键

   1. ctrl+A 移动到行首
   2. ctrl+E 移动到行尾
   3. ctrl+C
   4. ctrl+L
   5. ctrl+U 删除或剪切光标之前的命令
   6. ctrl+K 删除或剪切光标之后的命令
   7. ctrl+Y 粘贴
   8. ctrl+R 在历史命令中搜索
   9. ctrl+D 退出当前终端 或者 发送
   10. ctrl+Z 暂停
   11. ctrl+S 暂停屏幕输出
   12. ctrl+Q 恢复屏幕输出

5. 输入输出重定向

   1. Bash的标准输入输出

   2. | 设备   | 设备文件名  | 文件描述符 | 类型         |
      | ------ | ----------- | ---------- | ------------ |
      | 键盘   | /dev/stdin  | 0          | 标准输入     |
      | 显示器 | /dev/stdout | 1          | 标准输出     |
      | 显示器 | /dev/stderr | 2          | 标准错误输出 |

      输出重定向

      | 类型                           | 符号                      | 作用                                                   |
      | ------------------------------ | ------------------------- | ------------------------------------------------------ |
      | 标准输出重定向                 | 命令 > 文件               | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备中 |
      |                                | 命令 >> 文件              | 以追加的方式...                                        |
      | 标准错误输出重定向             | 错误命令 2>文件           | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备中 |
      |                                | 错误命令 2>>文件          | 以追加的方式...                                        |
      | **正确输出和错误输出同时保存** | 命令 > 文件 2>&1          | 以覆盖的方式，把正确和错误输出都保存到同一个文件中     |
      |                                | **命令 > 文件 2>&1**      | 以追加的方式...                                        |
      |                                | 命令 &> 文件              | 以覆盖的方式，把正确和错误输出都保存到同一个文件中     |
      |                                | **命令 &>>文件**          | 以追加的方式...                                        |
      |                                | **命令>>文件1  2>>文件2** | 把正确的输出追加到文件1中，把错误的输出追加到文件2中   |
      |                                |                           |                                                        |

   3. 输入重定向

      1. wc 选项 文件名
         1. -c 统计字节数
         2. -w 统计单词数
         3. -l 统计行数
      2. wc < abc
      3. wc << uio
         1. 然后开始输入 知道碰到下一个uio终止

   4. 多命令执行顺序

   - ls && echo yes || echo no

   - 后面两个部分不能颠倒，因为如果ls报错了 第二条命令会执行 那么第三条命令也会执行了

     | 多命令执符 | 格式                 | 作用                                                         |
     | ---------- | -------------------- | ------------------------------------------------------------ |
     | ;          | 命令1 ; 命令2        | 多个命令顺序执行，之间没有任何逻辑关系联系                   |
     | &&         | **命令1 && 命令2**   | 当命令1正确执行（$?=0），则命令2才执行，当命令1执行不正确（$?≠0），则命令2不会执行 |
     | \|\|       | **命令1 \|\| 命令2** | 当命令1执行不正确（$?≠0)，命令2才执行，当命令1执行正确）（$?=0），命令2不会执行 |

   5. 管道符
      1. 行命令提取命令 grep
         1. -A n 列出后续的n行
         2. -B n 列出前面的n行

   6. Bash中的其他符号

      | 符号 | 作用                                                         |
      | ---- | ------------------------------------------------------------ |
      | ''   | 单引号内所有符号丧失功能 变成普通字符串                      |
      | ""   | 双引号中的特殊符号都没有特殊含义，但是"$" "`" "\" 是例外，拥有调用变量值 引用命令和转义符的特殊含义 |
      | ``   | 反引号内是系统命令 Bash会先执行它 例如 a = date 只会把date字符赋值给a 而a=`date` 会把命令执行的结果赋值给a |
      | $()  | 和反引号作用一样 用来引用系统命令 推荐用这个 反引号和单引号容易看混 用这个提高可读性 |
      | ()   | 用于一串命令执行时，()中的命令会在子Shell中运行 子Shell中的命令 不会影响父Shell的变量 name=sc （name=lm）这时候父shell的name还是sc |
      | {}   | 用于一串命令执行时，{}中的命令会在当前Shell执行，也可以用于变量变形与替换 大括号的最后一个命令必须用分号 第一个命令和左括号之间必须有一个空格 |
      | []   | 用于变量测试 后面单独写                                      |
      | #    | 注释                                                         |
      | $    | 用于调用变量                                                 |
      | \    | 转义符 将特殊符号转换成普通符号                              |
      |      |                                                              |

### 变量和运算符

1. 什么是变量
   1. 变量的默认类型都是字符串型，如果要进行数值运算，则必须制定变量类型为数值型
   2. 变量用等号连接值，等号左右两侧不能有空格
   3. 变量的值如果有空格，需要使用单引号或者双引号包括，如test=“hello world”
   4. 可以进行变量值的叠加，不过变量需要用双引号包含"$变量名" 或用 ${变量名}  
      例如：test="$test"456  
      test=${test}456
2. 变量的分类
   1. 用户自定义变量：自定义变量名和变量的值
   2. 环境变量：这种变量中主要保存的是和系统操作环境相关的数据，比如当前登陆用户，用户的家目录，命令的提示符等。
      1. 用户自定义环境变量
      2. 系统自带环境变量
         1. 命令和作用是固定的 内容可以自定义 比如umask的值 history储存的条数
         2. 防止混淆 环境变量全部大写！！！
      3. 位置参数变量
         1. 这种变量主要是用来向脚本传递参数或者数据的
         2. 名称作用确定 内容可以自定义
         3. 比较少 要背
      4. 预定义变量
         1. 同样也是只能改内容
         2. 比较少 要背

### 自定义变量

1. 调用记得加$ 定义的时候不需要加
2. 查看 
   1. set 选项
      1. -u 设定此选项，调用未声明变量时会报错（默认无任何提示）常见选项！！
      2. -x 设定此选项，在民营执行之前，会把命令先输出一次 不大用
      3. 如果什么选项都不加 就会查看所有的变量
      4. 但是有一部分环境变量看不到 需要用env看(注意 env也看不全 他俩互补)
3. 删除
   1. unset 变量名
      1. 注意不需要加$



### 环境变量

1. 环境变量在全部的shell中都生效 而用户自定义变量只在当前shell生效
2. 声明
   1. export AGE="18"
   2. 也可以先AGE="18" 再export AGE
3. 查看
   1. set 看不到一部分环境变量
   2. env 看不到一部分环境变量 和 全部的自定义变量
4. 删除
   1. usnet AGE
5. 改
   1. 就是覆盖

### 系统自带的环境变量

1. PATH变量：系统查找命令的路径
   1. 各个路径用:分隔 我们可以在后面添加其他的目录 放置自定的命令
2. PS1变量：命令提示符设置
   1. 具体改可以查文档
   2. 就是shell中命令行左边的显示的东西
3. LANG语系变量
   1. 查询
      1.  locale -a 看可以支持的语言
   2. LANG="en_US. UTF-8"

### 位置参数变量

| 位置参数变量 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| $n           | 命令后第n个变量 $0是命令本身 10以上需要大括号 ${10} 缺点是没有提示 一般非作者根本不知道 命令后面应该输入什么  一般是用来写函数的 |
| $*           | 这个变量代表命令行中的所有参数，不过$*把所有的参数看成一个整体 |
| $@           | 这个变量也代表命令行中的所有参数，不过$@把每个参数区分对待   |
| $#           | 这个变量代表命令行中的所有参数的个数                         |
|              |                                                              |

- vi para.sh

- ```bash
  #!/bin/bash
  
  for i in "$*"
  	do
  		echo i
  	done
  	
  echo "===================="
  
  for j in "$@"
  	do
  		echo j
  	done
  ```

- ./para.sh 11 22 33 44

- ```bash
  11 22 33 44
  =========================
  11
  22
  33
  44
  ```



### 预定义变量

- 其实位置参数变量也是预定义变量 只是很常用

  | 预定义变量 | 作用                                                         |
  | ---------- | ------------------------------------------------------------ |
  | $?         | 最后一次执行命令的返回状态，如果这个变量的值为0，证明上一个证明正确执行；如果这个变量值为非0（具体哪个数由命令自己决定），则证明上一个命令执行不正确 |
  | $$         | 当前进程的ID号 PID                                           |
  | $!         | 后台运行的最后一个进程的PID                                  |
  |            |                                                              |

### 接收键盘输入

- **read 选项 变量名**

- -t 秒数：等待时间

- -p “提示信息”：等待输入时输出的提示信息

- -n 字符数：read命令只接受指定的字符数，就会执行

- -s：隐藏输入数据，适用于机密信息的输入

- ```bash
  #!/bin/bash
  
  read -t 30 -p "Please type in a number: " num1
  read -t 30 -p "Please type in another number: " num2
  
  sum=$(( $num1 + $num2 ))
  
  echo $sum
  
  ```



### Shell的运算符

1. 使用declare声明变量类型

   1. declare [+/-] 选项 变量名

      - declare -i $cc=$aa+$bb

      1. -：给变量设定类型属性
      2. +：取消变量的类型属性
      3. -a：声明为数组
         1. 其实数组直接用就行 因为格式比较特别
         2. name[0]="RenZhiheng"
         3. echo name[0]
      4. -i：声明为整数型
      5. -r：只读 一旦设置 既不能修改也不能删除 重启后失效
      6. -x：声明为环境变量
      7. -p：显示指定变量的被声明的类型

2. 数值运算方法

   1. declare法 不推荐 繁琐
   2. expr或let数值运算命令 不好用 expr命令里运算符两遍必须加空格 let稍微好点
   3. **$((运算式))**或者$[运算式] 推荐前者 因为[]还有测试的作用

   - ```bash
     #!/bin/bash
     
     read -t 30 -p "Num1 is: " num1
     read -t 30 -p "Num2 is: " num2
     read -n 1 -t 30 -p "The operator is[+-*/]: " oper
     
     ["$oper" == "+"] && echo "$(( $num1 + $num2 ))" && exit
     ["$oper" == "-"] && echo "$(( $num1 - $num2 ))" && exit
     ["$oper" == "*"] && echo "$(( $num1 * $num2 ))" && exit
     ["$oper" == "/"] && echo "$(( $num1 / $num2 ))" && exit
     
     echo "Incorrect input"
     
     
     #缺点很明显 没有判断num1和num2的输入是否正确 输错没有报错
     ```

     

3. 变量的测试与内容置换

   <table>
   <thead>
   <tr>
   <th>变量置换方式</th>
   <th>变量y没有设置</th>
   <th>变量y为空值</th>
   <th>变量y设置值</th>
   </tr>
   </thead>
   <tbody>
   <tr>
   <td>x=${y-新值}</td>
   <td>x=新值</td>
   <td>x为空</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y:-新值}</td>
   <td>x=新值</td>
   <td>x=新值</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y+新值}</td>
   <td>x为空</td>
   <td>x=新值</td>
   <td>x=新值</td>
   </tr>
   <tr>
   <td>x=${y:+新值}</td>
   <td>x为空</td>
   <td>x为空</td>
   <td>x=新值</td>
   </tr>
   <tr>
   <td>x=${y=新值}</td>
   <td>x=新值 y=新值</td>
   <td>x为空 y值不变</td>
   <td>x=$y y值不变</td>
   </tr>
   <tr>
   <td>x=${y:=新值}</td>
   <td>x=新值 y=新值</td>
   <td>x=新值 y=新值</td>
   <td>x=$y y值不变</td>
   </tr>
   <tr>
   <td>x=${y?新值}</td>
   <td>新值输出到标准错误输出（就是屏幕）</td>
   <td>x为空</td>
   <td>x=$y</td>
   </tr>
   <tr>
   <td>x=${y:?新值}</td>
   <td>新值输出到标准错误输出</td>
   <td>新值输出到标准错误输出</td>
   <td>x=$y</td>
   </tr>
   </tbody>
   </table>



### 环境变量配置文件

1. source命令  让环境变量配置文件直接生效

   1. source 配置文件
   2. . 配置文件

2. **环境变量配置文件**

   1. 登陆时生效的环境变量配置文件有以下五个：

      - /etc/profile
      - /etc/profile.d/*.sh
      - ~/.bash_profile
      - ~/.bashrc
      - /etc/bashrc

      其中etc下的对所有用户生效

   2. 环境变量配置文件的调用过程

      ![环境变量配置文件调用过程](/Users/wenchaoli/Desktop/Images/环境变量配置文件调用过程.png)

      {其中的具体内容 包括两条调用路线：登陆与非登陆(sudo)}(https://www.bilibili.com/video/BV1ut411a7ro?p=126)

   3.   注销时生效的环境配置文件~/.bash_logout
   
      1. 这个文件默认没有写入任何内容，可是如果我们希望再退出登录执行一些操作，比如hostory -c，备份某些数据，就可以把命令写入这个文件。
   
   4. 其他配置文件
   
      1. ~/bash_history 也就是历史命令的保存文件。
      2. Shell登录信息
         1. /etc/issue
            1. 也就是所谓的欢迎信息
            2. 其中的转义符代表的具体信息 man aagetty查询
            3. 常用的是\l显示当前终端号
         2. /etc/issue.net
            1. 远程登陆生效
            2. 同时要修改ssh的配置文件/etc/ssh/sshd_config 中的Banner none 为 Banner /etc/issue.net 
               因为ssh远程登录决定是否执行/etc/issue.net
            3. 注意/etc/issue.net不能支持issue文件中的转义符
            4. 重启生效
         3. etc/motd
            1. 也是欢迎信息，不同点是这个文件的欢迎信息在正确输入用户名密码登陆之后显示，这个不论是本地还是远程登陆都可以显示
            2. 一般写的是警告信息，如果你没有被授权，请你离开
            3. 一般来说这个常用一些
         4. 定义Bash快捷键
            1. stty -a 查询所有快捷键
            2. stty 关键字 快捷键
               1. stty intr ^p	ctrl+p强制终止
               2. 并不建议改



## Shell编程

### 正则表达式

1. 概述
   - 和通配符的区别
     - 完全匹配和包含匹配
   - 支持正则的常用命令
     - grep
     - awk
     - sed
   - 支持通配符的常用命令
     - ls
     - find
     - cp
2. 基础正则表达式

| 元字符     | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| *          | 前一个字符匹配0次或任意多次 注意a*没有任何意义 因为可以为0个 aa\*才代表至少包含1个a 但是这种情况直接搜a就行了 因为是包含匹配 |
| .          | 匹配除换行符外任意一个字符                                   |
| ^          | 匹配行首                                                     |
| $          | 匹配行尾 "^$"可以匹配空白行 主要用来取反 剔除空白行 grep -v "^$" test.txt |
| [] [-]     | 匹配中括号中指定或指定范围的任意一个字符                     |
| [^]        | 取反 ^[ ^a-zA-Z] 匹配不以字母开头的内容 **注意！[^]匹配除中括号的字符以外的任意一个字符** |
| \          | 转义符 \\.$ 匹配以.结尾的                                    |
| \\{n\\}    | 前一个字符刚好出现了n次 "^[0-9]\\{3\\}[ ^0-9]" 一般用于数字  注意前后一般要有限位符 因为是包含匹配 |
| \\{n, \\}  | 前一个字符出现了大于等于n次                                  |
| \\{n, m\\} | 前一个字符出现了大于等于n次小于等于m次  "sa\\{1, 3\\}i"      |
|            |                                                              |

3. 扩展正则表达式(egrep 或者 grep -E 来支持)

| 扩展元字符 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| +          | 前一个字符匹配1次或多次                                      |
| ?          | 前一个字符匹配0或1次                                         |
| \|         | 匹配两个或多个分支选择 was\|were 会匹配包含was的也匹配包含were的 |
| ()         | 匹配以整体进行，即模式单元 (hey)+ 会匹配hey出现1次或多次的字符串 |

4. 正则实例
   1. 匹配邮箱：  
      [0-9a-zA-Z\_]+@[0-9a-zA-Z\_]+(\\.[0-9a-zA-Z\_]+)\\{1, 3\\}   
      注意：grep -E 之后的正则会跟一般语言的正则类似于 表示出现次数范围的正则元字符不用加反斜杠了  
      grep -E [0-9a-zA-Z\_]+@[0-9a-zA-Z\_]+(\\.[0-9a-zA-Z\_]+){1, 3} mails.txt
   2. 过滤IP：建议用程序 不要用正则 太复杂 每一位是从0-255而不是0-999



### 字符的截取和替换

1. cut 列提取命令

   - cut 选项 文件名
     - -f 列号
     - -d 分隔符：按照指定的分隔符分割列 默认为tab制表符 不识别空格
     - -c 字符范围： 不依赖分隔符来区分列，而是通过字符范围（行首为0）来进行字段提取 “n-”表示从第n个字符到行尾 同理“n-m” “-m”  不咋好用 每列的字符数不确定

2. awk编程

   1. 概述

   2. printf格式化输出

      - printf '输出类型输出格式' 输出内容
        - 输出类型
          - %ns：输出字符串 n个字符
          - %ni：输出n个整数
          - %m.nf：输出浮点数 共m位 其中n位小数
        - 输出格式
          - \a：输出警告声
          - \b：输出退格键
          - \f：清屏
          - \n：换行
          - \r：回车
          - \t：Tab
          - \v：垂直Tab
        - printf '%s' $(cat test.txt)

   3. awk的基本使用

      1. awk '条件1 {动作1} 条件2 {动作2} ...' 文件名
      2. 例子：  
         awk ' {printf $2 "\\t" $6 "\\n"}' student.txt
      3. df -h | awk " {printf $5 "\\n"}"
      4. df -h | grep "dev/sda3" | awk ' {printf $5 "\\n"}' | cut -d "%" -f 1  
         查看根分区的使用占比（假设根分区是sda3）

   4. awk的条件

      | 条件的类型 | 条件    | 作用                                         |
      | ---------- | ------- | -------------------------------------------- |
      | awk保留字  | BEGIN   | 在执行后续命令之前优先执行                   |
      |            | END     |                                              |
      | 关系运算符 | >       |                                              |
      |            | <       |                                              |
      |            | \>=     |                                              |
      |            | \<=     |                                              |
      |            | ==      |                                              |
      |            | !=      |                                              |
      |            | A~B     | 判断字符串A中是否包含能匹配B表达式的子字符串 |
      |            | A!~B    |                                              |
      | 正则       | /regex/ |                                              |

      1. awk首先执行BEGIN 然后一行一行执行，先把整行给$0 然后每一列赋给对应的$n，然后进行条件判断例如$1 >= 80 或者 $3 ~ /name/ 然后执行相应的动作 最后则执行END
      2. 当然条件里可以直接用正则 注意必须用/正则/括起来才能识别字符串  
         awk ' /WangGang/ {printf $5 "\\n"}' student.txt  
         这个相当于在整行里搜索包含WangGang的情况 如果有 输出那一行里对应的列

   5. awk内置变量

      | awk内置变量 | 作用                                                         |
      | ----------- | ------------------------------------------------------------ |
      | **$0**      | 目前awk所读入的整行数据                                      |
      | **$n**      | 代表当前读入行的第n个字段                                    |
      | **NF**      | 当前行拥有的子段总数                                         |
      | **NR**      | 当前awk所处理的行，是总数据的第几行                          |
      | **FS**      | 用户定义分隔符awk的默认分隔符是任何空格，如果想要使用其他分隔符如：就需要FS变量定义 |
      | ARGC        | 命令行参数个数                                               |
      | ARGV        | 命令行参数组数                                               |
      | FNR         | 当前文件中的当前记录数（对输入文件起始为1）                  |
      | OFMT        | 数值的输出格式 默认为%. 6g                                   |
      | OFS         | 输出字段的分隔符 默认为空格                                  |
      | ORS         | 输出记录分隔符 默认为换行符                                  |
      | RS          | 输入记录分隔符 默认换行符                                    |

      1. cat /etc/passwd | grep "/bin/bash" | awk ' {FS=":"} {printf $1 "\\n"}'  
         这是有问题的，因为awk已经读入了$0才知道了分隔符是：所以第一行没处理成功  
         cat /etc/passwd | grep "/bin/bash" | awk ' BEGIN {FS=":"} {printf $1 "\\n"}'  
         cat /etc/passwd | grep "/bin/bash" | awk ' BEGIN {FS=":"} $3=="500" {printf $1 "\\n"}'  
      2. 进阶：  
         cat /etc/passwd | grep "/bin/bash" | awk ' BEGIN {FS=":"} {printf $1 "\\t" $3 "\\t 行号：" NR "\\t 字段数：" NF "\\n"}'    
         字符串和转义字符需要放在双引号里 变量放在外面

3. sed命令

   - sed主要是用来将数据进行选取 替换  删除 新增的命令
   - sed 选项 '动作' 文件名

   | 选项          | 作用                                                         |
   | ------------- | ------------------------------------------------------------ |
   | -n            | sed默认会把所有数据都输出到屏幕，如果加入-n，则只会把经过sed处理的行输出到屏幕 |
   | -e            | 允许对输入数据应用多条sed命令编辑                            |
   | -f 脚本文件名 | 从sed脚本中读入sed操作，和awk中的-f非常类似                  |
   | -r            | 在sed中支持扩展正则表达式                                    |
   | -i            | 用sed的修改结果直接修改读取数据的文件而不是输出到屏幕上      |
   | **动作**      |                                                              |
   | a \           | 追加 在当前行后添加一行或多行 添加多行时 用\表示数据未完结 也就是换行 |
   | i \           | 插入                                                         |
   | d             | 删除                                                         |
   | p             | 打印 输出指定行                                              |
   | s             | 字串替换 用一个字符串替换另外一个字符串，格式为“行范围 s/旧字串/新字串/g” |

   - 例子：
     - sed -i -e '3d ; 4d' test.txt
       - 注意 -e需要挨着命令
     - sed -n '2, 5d' test.txt
     - sed 's/LiGang/WangGang/g' test.txt



### 字符处理命令

1. 排序命令sort
   - sort 选项 文件名
     - -f 忽略大小写
     - -b 忽略行前空白部分
     - -n 以数值型进行排序，默认使用字符串型排序
     - -r 反向排序
     - -u 删除重复行 就是uniq命令
     - -t 指定分隔符，默认时制表符
     - -k n, m 按照指定的字段范围排序，从n字段开始到m字段结束 如果不输入, m 就默认到行尾
   - sort -n -k 3, 3 /etc/passwd
     - 如果不用-n是按照字段的首字母进行排序 导致11排在2前面
2. uniq
   - uniq 选项 文件名
3. 统计 wc
   - wc 选项 文件名
     - -l 只统计行数
     - -w 只统计单词数
     - -m 只统计字符数



### 条件判断 test 或者 [测试选项 文件名]

1. 按照文件类型进行判断

   | 测试选项    | 作用                                    |
   | ----------- | --------------------------------------- |
   | -b 文件     | 是否块设备                              |
   | -c 文件     | 是否字符设备文件                        |
   | **-d 文件** | 是否目录 目录为真  [-d abc] 然后echo $? |
   | **-f 文件** | 是否普通文件                            |
   | **-L 文件** | 是否为符号链接文件                      |
   | -p 文件     | 是否为管道文件                          |
   | **-s 文件** | 是否文件为空 非空为真                   |
   | -S 文件     | 是否为套接字文件                        |
   |             |                                         |

2. 按照文件权限判断

   | 测试选项    | 作用                                                         |
   | ----------- | ------------------------------------------------------------ |
   | **-r 文件** | 判断该文件是否存在，并且是否该文件拥有读权限 有为真 注意判断的整个文件的权限 无法具体区分是所有者所属组和其他的 |
   | **-w 文件** | 写                                                           |
   | **-x 文件** | 执行                                                         |
   | **-u 文件** | SUID                                                         |
   | **-g 文件** | GUID                                                         |
   | **-k 文件** | SBit                                                         |
   |             |                                                              |

3. 两个文件之间进行比较

   | 测试选项            | 作用                                            |
   | ------------------- | ----------------------------------------------- |
   | **文件1 -nt 文件2** | 判断文件1的修改时间是否比文件2新 新为真         |
   | 文件1 -ot 文件2     | 旧为真                                          |
   | **文件1 -ef 文件2** | 判断inode是否一致 一致为真 是判断硬链接的好方法 |

4. 两个整数之间的比较

   | 测试选项            | 作用              |
   | ------------------- | ----------------- |
   | **整数1 -eq 整数2** | 是否相等 相等为真 |
   | **整数1 -ne 整数2** | 不相等为真        |
   | **整数1 -gt 整数2** | 整数1>整数2 为真  |
   | **整数1 -lt 整数2** | 小于为真          |
   | **整数1 -ge 整数2** | 大于等于为真      |
   | **整数1 -le 整数2** | 小于等于为真      |

5. 字符串的判断

   | 测试选项       | 作用                                                 |
   | -------------- | ---------------------------------------------------- |
   | -z 字符串      | 是否为空 为空为真                                    |
   | **-n  字符串** | 非空为真                                             |
   | 字串1 == 字串2 | 判断字符串1是否和字符串2相等 相等为真 ["$a" == "$b"] |
   | 字串1 != 字串2 | 不等为真                                             |

6. 多重判断

   | 测试选项       | 作用        |
   | -------------- | ----------- |
   | 判断1 -a 判断2 | 与 皆真为真 |
   | 判断1 -o 判断2 | 或          |
   | ！判断         | 非          |



### 流程控制

1. if 条件判断

   - 单分支

     - ```bash
       #!/bin/bash
       if [condition]
       	then
       		#code
       fi
       ```

     - example:   

       ```bash
       #!/bin/bash
       
       aa=$(df -h | grep /dev/sda3 | awk ' {printf $5 "\n"' | cut -d "%" -f 1)
       
       if ["%aa" -ge 80]
       	then
       		echo "greater than 80 !"
       fi
       ```

       chmod 755 example.sh  
       ./example.sh

   - 双分支

     ```bash
     #!/bin/bash
     if [condition]
     	then 
     		#code
     else
     	#code
     fi
     ```

     - example(稍微不太合理 只是个例子) 备份mysql  

       ```bash
       #!/bin/bash
       
       ntpdate asia.pool.ntp.org &>/dev/null
       #同步时间
       
       date=$(date +%y%m%d)
       #日期按照年/月/日格式
       
       size=$(du -sh /var/lib/mysql)
       #统计mysql数据库的大小
       
       if [-d /tmp/dbbak]
       #判断备份目录是否存在，是否为目录
       	then
       		#如果为真执行一下脚本
       		echo "Date: $date!" > /tmp/dbbak/dbinfo.txt
       		#把当前日期写入临时文件
       		echo "Data size: $size" >> /tmp/dbbak/dbinfo.txt
       		#把大小写入
       		cd /tmp/dbbak
       		#进入备份目录
       		tar -zcf mysql-lib-$date.tar.gz /var/mysql dbinfo.txt &>/dev/null
       		#打包压缩数据库与临时文件
       		#注意/dev/null相当于垃圾站 把命令的输出丢进垃圾站就会屏蔽它 但是报错会正常报错 写脚本很常用
       		rm -rf /tmp/dbbak/dbinfo.txt
       		#删除临时文件
       else
       	mkdir /tmp/dbbak
       	#如果判断为假，则建立备份目录
       	echo "Date: $date!" > /tmp/dbbak/dbinfo.txt
       	echo "Date size: $size" >> /tmp/dbbak/dbinfo.txt
       	#保存数据库大小和当前日期
       	cd/tmp/dbbak
       	tar -zcf mysql-lib-$date.tar.gz dbinfo.txt /var/lib/mysql &>/dev/null
       	rm -rf /tmp/dbbak/dbinfo.txt
       fi
       #问题是 备份和原始数据在一块硬盘里 而且只能完全备份
       ```

     - exmple2 每五分钟检测apache有没有当机并重启

       ```bash
       #!/bin/bash
       
       aa=$(netstat -tuln | awk ' {printf $4 "\n"}' | grep ":80&")
       
       if ["$aa" == ""]
       	then
       		echo "httpd is down, restarting..."
       		/etc/tc.d/init.d/httpd start &>/dev/null
       else
       	echo "httpd is working fine"
       fi
       ```

     - nmap -sT 192.168.4.210

       - 扫描本机所有端口 看看有无应答  
         $(nmap -sT 192.168.4.210 | grep tcp | grep httpd | awk ' printf $2 "\\n"') == "open"  
         判断有无应答 因为有的时候虽然服务开启 访问量量过大会导致无应答

   - 多分支

     ```bash
     if [condition]
     	then
     		do
     elif
     	do
     else
     	do
     fi
     ```



### Primitive Calculator

```bash
#!/bin/bash
#Command line calculator Ver0.1

read -t 30 -p "Please enter the first operand: " num1
read -t 30 -p "Please enter the operator: " op
read -t 30 -p "Please enter the second operand: " num2

if [ -n "$num1" -a -n "$num2" -a -n "$op" ]
	then
	ifInt1=$(echo $num1 | sed ' s/[0-9]//g')
	ifInt2=$(echo $num2 | sed ' s/[0-9]//g')
	
	if [ "$ifInt1" == "" -a -z "$ifInt2" ]
		then
		if [ "$op" == "+" ]
			then 
			result=$(($num1 + $num2))
		elif [ "$op" == "-" ]
			then
			result=$(($num1 - $num2))
		elif [ "$op" == "*" ]
			then
			result=$(($num1 * $num2))
		elif [ "$op" == "/" ]
			then
			result=$(($num1 / $num2))
		else
			echo "Please enter a valid operator"
			exit 11
		fi
	else
		echo "Please enter valid operands"
		exit 11
	fi
else
	echo "Please assign all 3 variables properly"
	exit 11
fi

echo "$num1 $op $num2 = $result"
```



### Case Statement

- ```bash
  case $var in
  	"val1")
  		do
  		;;
  	"val2")
  		do
  		;;
  	"val3")
  		do
  		;;
  	*)
  		do
  		;;
  esac
  ```



### for loop

- ```bash
  #Most common one for system maintenance
  for var in val1 val2 val3 ...
  	do
  		echo $var
  	done
  ```

- ```bash
  #Common in other langs
  s=0
  for (( i=1;i<=100;i=i+1 ))
  	do
  		echo s=$(( $s + $i ))
  	done
  ```

- ```bash
  #Batch decompressing
  #ls *.tar.gz > tar.log
  #ls *.tgz >> tar.log &>/dev/null
  aa=$( cat /root/sh/tar/tar.log | wc -l)
  
  for((i=1;i<="$aa";i=i+1))
  do
  	bb=$( cat tar.log | awk 'NR=="$i" {printf $1 "\n"}' )
  	tar -zxvf $bb -C /root/sh/tar
  done
  
  #The better version
  ls *.tar.gz > tar.log
  
  for i in $(cat tar.log)
  do
  	tar -zxvf $i
  done
  
  #This is why you'll see the first type of for loop way more often... it would be silly to use it for arithmetic purposes though
  ```

- ```bash 
  #!/bin/bash
  #Legal IP filter
  #Use regex as a sketchy filter
  
  grep "^[0-9]\[1,3\].[0-9]\[1,3\].[0-9]\[1,3\].[0-9]\[1,3\]$" /root/sh/ip.txt > /root/sh/ip_test1.txt
  
  #Get the num of IPs we got
  line=$(wc -l /root/sh/ip_test1.txt | awk ' {printf $1 "\n"}')
  #line=$(cat ip_test1.txt | wc -l)
  
  #Get your final file ready
  echo "" > /root/sh/ip_test.txt
  
  for (( i=1;i<$line;i=i+1 ))
  #for i in $(cat /root/sh/ip_test1.txt)
  do
  	cat /root/sh/ip_test1.txt | awk 'NR=='$i'{print}' > /root/sh/ip_test2.txt
  	#In the file, there lies the only one IP of the ith column
  	#Type 2 for-loop body starts from here
  	a=$( cat /root/sh/ip_test2.txt | cut -d '.' -f 1)
  	b=$( cat /root/sh/ip_test2.txt | cut -d '.' -f 2)
  	c=$( cat /root/sh/ip_test2.txt | cut -d '.' -f 3)
  	d=$( cat /root/sh/ip_test2.txt | cut -d '.' -f 4)
  	
  	if [ "$a" -lt 1 -o "$a" -gt 255 ]
  		then
  			continue
  	fi
  	
  	if [ "$b" -lt 0 -o "$b" -gt 255 ]
  		then
  			continue
  	fi
  	
  	if [ "$c" -lt 0 -o "$c" -gt 255 ]
  		then
  			continue
  	fi
  	
  	if [ "$d" -lt 0 -o "$d" -gt 255 ]
  		then
  			continue
  	fi
  	
  	cat /root/sh/ip_test2.txt >> /root/sh/ip_test.txt
  	
  done
  
  rm -rf /root/sh/ip_test1.txt
  rm -rf /root/sh/ip_test2.txt
  
  #To be validated...
  ```

- ```bash
  #batch adding a fixed number of users
  
  read -t 30 -p "User name: " name
  read -t 30 -p "Number of users: " num
  read -t -30 -p "Password: " pwd
  
  if [ -n "$name" -a ! -z "$pwd" -a -n "$num" ]
  	then
  	y=$(echo $num | sed ' s/[0-9]//g')
  	if [ -z "$y" ]
  		then
  		for (( i=1;i<$num;i=i+1 ))
  			do
  				/usr/sbin/useradd $name$i &>/dev/null
  				echo $pwd | /usr/bin/passwd --stdin $name$i &>/dev/null
  				chage -d 0 $name$i &>/dev/null
  			done
  	fi
  fi
  ```

- ```bash
  #!/bin/bash
  #Batch deleting users. Avoid deleting root and system users
  
  user=$(cat /etc/passwd | grep "/bin/bash" | grep -v "root" | cut -d ":" -f l)
  
  for i in $user
  	do
  	 userdel -r $i
  	done
  ```



### while loop

- ```bash
  while [condition]
  	do
  	 code
  	done
  ```

- Not common since it's for arithmetic mainly.



### until loop

- ```bash
  until [condition]
  	do
  		code
  	done
  ```



### Function

- ```bash
  function func {
  	echo $1
  }
  func Hello
  func World
  
  ```

- ```bash
  func () {
  	echo Hello $1
  	local var = 'local'
  }
  
  var = 'global'
  func Mars
  ```



Other Flow Control Commands

1. exit
   - exit [value]
   - exit the current script

2. break
   - Jump out of the current loop completely
3. continue
   - End the current iteration(1 time execution of loop) and execute the next in the loop if possible



## 启动引导和系统修复

### 概念

1. 系统运行级别	

   - | 运行级别 | 含义                                               |
    | -------- | -------------------------------------------------- |
   | 0        | 关机                                               |
   | 1        | 单用户模式，主要用于系统修复 （对表win的安全模式） |
   | 2        | 不完全的命令行模式，不含NFS服务                    |
   | 3        | 完全的命令行模式，就是标准字符界面                 |
   | 4        | 系统保留                                           |
   | 5        | 图形模式                                           |
   | 6        | 重启动                                             |
   
   - runlevel
      - x y
      - x is the previous level before entering the current one
      - y is the current runlevel
   
   - init n
      - enter level n
      - not safe using this to reboot

2. System Default Runlevel
   
   - /etc/inittab
3. /etc/rc.local or /etc/rc.d/rc.local
   - This will be executed before user login
   - You can run apache while system starts by edit this file

### Boot Loader 启动引导程序

1. /boot/grub

   - boot/grub/grub.conf & menu.lst (soft link)
     - partition representation
       - hd(x,y)
         - x for the number of current SCSI disk starting from 0
         - y for the current partition starting from 0
           - 0 - 3 for primary partition
           - 4 -    for logic partition

2. /boot/grub/splash.xpm.gz

   - The background of booting interface

3. grub configuration

   - Notice that you cannot do anything through distant control since the network module has't been loaded yet

   - default=0
     - boot the first sys as default after x seconds if no choce was made
   - timeout=5
     - waiting time of selecting  sys
     - if it's -1, sys will wait till any decision is made
   - splashimage=(hd0,0) /grub/splash.xpm.gz
     - where the background image is located
   - hiddenmenu
     - by default, the menu is hidden, you can see the counting only. cancel it by commenting the line.
   - title
     - display this for the corresponding sys
   - root *(hd0,0)*
     - where is the root directory
     - notice it doesn't stand for the root user
   - kernal _content_
     - /vnlinuz-2.6.32-279.el6.i686
       - indicate the location of the kernal files
       - and the '/' means /boot here
     - ro
       - mount the /boot as read-only
     - it bans RAID, LVM... that's why you can only mount your /boot on the primary partition when installing the sys
     - root=UUID.....
     - KEYBOARDTYPE=pc KEYTABLE=US
     - LANG
       - language env
     - rhgb
       - use image to substitute the literal info
       - you can check the literals with command *dmesg*
     - quiet
       - hide the boot messages except the important ones
     - initrd/initramfs....
       - indicate the location of the *img* of the memory files

4. grub encryption

   - grub-md5-crypt

   - Then the sys will show the md5 code

   - copy it

   - vim /etc/grub.config

   - put it at the line after "timeout=5" as below  
     password --md5 *here is the md5 code*

   - now if you want to edit the passwd while the grub interface, a password is needed

   - if you add lock after the title... that would be a disaster since you need the password for booting and the distant tool cannot connect...   
     Check the flight LOL

     | 系统密码-->    | grub密码-->      | BIOS密码   |
     | -------------- | ---------------- | ---------- |
     | 单用户模式破解 | 光盘安全模式破解 | 扣主板电池 |

   

### System Repair

1. Single User Mode
   - runlevel 1
   - Need to be with the server pysically
   - at grub interface enter the os
   - press e to edit
   - append ' 1' after the quiet
   - notice there is a space between quiet and 1
   - it means to enter runlevel 1 this time (cause it's a temporally change, edit the config file to change it permanently)
   - passwd root
   - reboot
2. CD-ROM Repair
   - Need to pysically be with the server
   - BIOS --> boot from CD
   - Rescue install mode
   - continue
   - start shell
   - Notice we did not enter the real /  
     the CDROM simulated this one
   - chroot /mnt/sysimage
   - change the root to the real one since the it's treated as an external device
   - do whatever you need to repair the sys



## Services Management System 服务管理系统

### Classification

1. RPM package installed
   1. Independent
      - directly listed in memory
      - chkconfig --list
        - if there shows 0-6, it's a inde service
          - notice that 0-6 show the options under different runlevel
   2. Based on xinetd
      - only xinetd service is on memory, other services will be managed by it (Not the mainsteam now since the server is much more powerful and there is no need to save that little memory)
2. Source code package installed



### Services installed by RPM

#### Independent Services

1. start

   1. /etc/init.d/*serviceName* start
   2. service *serviceName* start|stop|restart|...

2. automatic

   1. chkconfig --level *runlevelNum* *serviceName* on|off
      - **Next time** of booting it will run automatically
   2. /etc/rc.local
      - add a standard way of starting
      - **This method is recommended**
   3. ntsysv

   - Notice: ckconfig cannot check the service started by /etc/rc.local, vise-versa
   - And Only one way for the auto start, if it's started more than once, you'll earn your error message

#### xinetd

- I don't care about it because no one will use it nowadays

#### Example of Apache

- /etc/rc.d/init.d/httpd



### Services installed by Source Code

1. start
   1. start by the command (check its offical docs)
      - /usr/local/apache2/bin/apachectl start|stop|restart|...
2. auto
   - vim /etc/rc.local
     - add --> /usr/local/apache2/bin/apachectl start
3. let the source code service be recognized  by service & chkconfig & ntsysv (**not recommended since you can not distinguish RPM and Source code versions of services**)
   1. ln -s /usr/local/apache2/bin/apachectl /etc/rc.d/init.d/
      - now it's good with service command
   2. vim /etc/rc.d/init.d/apachectl
      - add --> chkconfig: 35 86 76
        - 35 is the runlevel 3 and 5
        - 86 is the starting sequence, just make sure it's not conflict with other services
        - 76 is the ending sequence, notice the same thing above
      - chkconfig --add apachectl
      - chkconfig --list | grep "apachectl"
      - now should be good with chkconfig & ntsysv



### Common Services in Linux

- | Service Name                                                 | Function | Recommendation |
    | ------------------------------------------------------------ | -------- | -------------- |
  | [See here](https://www.bilibili.com/video/BV1ut411a7ro?p=169) |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |
  |                                                              |          |                |



## System Management

### Process

1. What is process
2. The functions of porcess management
   1. check if the system is running healthy
      - 70/90 principle: mem < 70%   cpu < 90%  
        change it with your needs
   2. check all processes status
   3. kill a process (**rare**)
3. Check a process
   1. ps command
      - ps aux
        - no '-'
        - a: show all processes on the terminal except 会话引线
        - u: show the owner of the processes and mem usage
        - x: show the processes without terminal control
      - USER
      - PID
      - %CPU
      - %MEM
      - VSZ: the virtual mem occupied
      - RSS: the physical mem occupied
      - TTY: on which terminal it runs
        - if it's ?, means it is started by the kernal
      - STAT: status od the process
        - D: sleep status that cannot be awoke
        - R: running
        - S: sleep
        - ... check the docs
      - START
      - TIME
      - COMMAND (usually the most useful part to know what on earth is the process you are looking at)
   2. top command
      1. -d n: n is the number of seconds to refresh, set to 3 by default
      2. [too lazy today...check here](https://www.bilibili.com/video/BV1ut411a7ro?p=172)
      3. the most important parts are average loads, cpu idle, mem and swap free
      4. interaction
         1. P: sorted by CPU usage
         2. M: sorted by mem usage
         3. q: quit
      5. options
         1. -p pid: check a specific process
         2. -b
         3. -n
         4. common use: top -b -n 1 > test
   3. pstree -p



### Process Management

1. check signal: kill -l
   - SIGHUP: shutdown the process immediately, read the config file and reboot
   - SIGKILL: to end a process at once, this signal cannot be stopped, processed, or ignored. common for terminate processes forcedly
2. kill process
   1. kill signal PID
      1. kill -9 53734 forcedly shutdown a process
   2. killall option signal processName
      1. -i: interactive
      2. -I: ignore the capitalization of processName
      3. kill -9 httpd (common for kill processes of a service)
   3. pkill option signal processName
      1. -t: terminal number
         - pkill -9 -t pts/1 (common for kick out users)
         - kick out the distant terminal pts/1



### Jobs Management

- [Cautions](https://www.bilibili.com/video/BV1ut411a7ro?p=174)
- Put command to backstage
  - command &
  - ctrl+z: pause and put it to backstage
- Query
  - ​	jobs command
    - jobs -l
    - check all backstage services with PID
- Recover
  - fg %jobNum: put the job back to frontstage
  - bg %jobNum: recover the stopped backg3round job to excute
- Seperate the job from terminals
  - edit the /etc/rc.local (drawback: need to reboot)
  - realize through system tasks
  - nohup [command] &



### System Resource Query

1. vmstat refreshDelay refreshTimes
   - vmstat 1 3
     - refresh every sec for 3 times
2. dmesg | grep keywords
   - get info from booting messages
3. free -h
4. /proc/cpuinfo
5. /proc/meminfo
6. uptime
7. uname   this is kernalinfo
   1. -a
   2. -r
8. file /bin/ls
   - check if the os is 32-bit or 64-bit
9. lsb_release -a
   - check the release ver



### 系统定时任务

1. at 一次性执行定时任务
   1. at 服务管理与访问控制
      - at 是由atd服务支持的 首先启动atd 或者将它设置为自启动 当然 一般是默认启动的
        - service atd start
        - chkconfig atd on
      - at 的访问控制
        - /etc/at.deny 
        - /etc/at.allow 默认不存在
          - 他的优先度高
          - 一旦存在 只有写入这个文件的用户能执行at
          - 还得在文件中手动加入用户
        - 如果两个文件都没有，则只有root能使用at
   2. at 选项 时间
      - -m 工作完成后 email通知
      - -c 工作号 显示at工作的实际内容
      - 时间的格式
        - HH:MM
        - HH:MM[am|pm] [month] [date]
        - HH:MM[am|pm] + [minutes|hours|days|weeks] 在指定的时间再加多久执行
      - 输入命令内容
      - ctrl+D发送
   3. 查询at任务
      - at -c
      - atq
   4. 删除
      - atrm 工作号
2. **crontab循环定时任务**
   1. 服务管理和访问控制
      1. 由crond服务支持
         - service crond restart
         - chkconfig crond on
      2. /etc/cron.deny & /etc/cron.allow
   2. 用户的crontab设置
      - -e：编辑crontab定时任务
      - -l：查询
      - -r：删除当前用户所有的crontab任务，如果有多的任务只想删除一个，可以用 crontab -e
      - -u 用户名：修改或删除其他用户的crontab任务 只有root可以用
      - 或者可以用root修改/etc/crontab  并且可以指定其他用户来执行
      - **格式：\* \* \* \* \* 执行的任务**
        - 一小时中的第几分钟 0-59
        - 一天中的第几个小时 0-23
        - 一个月当中的第几天 1-31
        - 一年当中的第几个月 1-12
        - 一周中的星期几 0-7
      - 10 \* \* \* \* 命令 代表每个小时的第10分钟执行一次
      - 0 8, 12, 16 \* \* \* 命令 代表每天的8点0分 12点0分 16点0分 都执行一次
      - 0 5 \* \* 1-6 命令 周一到周六5点执行
      - \*/10 \* \* \* \* 命令 每隔10分钟 执行一次
      - 0 0 1, 15 \* 1 命令 每个月的1号15号和每周1都会执行！最好不要这么写 因为容易搞晕别的管理员
   3. 注意事项
      1. 六个选项都不能为空 不确定就用*
      2. 最小是分钟 最大是月 没法确定年和秒
      3. 星期和天不要同时出现 便于理解
      4. 定时任务 所有都用绝对路径
   4. 系统的crontab设置
      1. crontab -e 是每个用户执行的命令
      2. 其他两种方法
         1. 直接修改/etc/crontab
            - 修改配置文件 定时任务的执行者默认是当前用户
            - 0 \* \* \* \* root runparts /etc/cron.hourly/
            - 每小时0分钟 用root用户的身份 用runparts脚本 执行目录下的每一个
         2. 把脚本放入相应的执行目录 /etc/cron.hourly/或者/etc/cron.daily/等  
            但是没法设置具体的时间，是系统自己决定的
3. anacron
   - /var/spool/anacron
   - 如果该执行任务的时候因为某种任务没有执行 比如关机了 它会检测所有的定时任务，看情况补上没执行的任务
   - 新版本/etc/cron.{hourly｜daily｜weekly}是由anacron自动调用的 以防止cron和anacron重复执行任务发生报错
   - anacron 选项 工作名
     - /etc/anacrontab
       - RANDON_DELAY=45 开机之后45分钟内任意时间开始执行第一个任务 然后45分钟内执行第二个...以此类推
       - START_HOURS_RANGE=3-22 允许执行时间为3点到22点



## 日志管理

### 简介

- LAMP下的ELK的日志分析工具

1. 常见日志

    

   | 日志文件         | 作用                                                         |
   | ---------------- | ------------------------------------------------------------ |
   | /var/log/cron    | 定时文件                                                     |
   | /var/log/cups/   | 打印信息                                                     |
   | /var/log/btmp    | 记录错误登陆日志 二进制文件 要用lastb命令查看                |
   | /var/log/lastlog | 所有用户最后登陆时间的日志 lastlog查看                       |
   | /var/log/mailog  | 邮件信息                                                     |
   | /var/log/message | 系统重要信息日志 如果系统出现问题 首先查这个                 |
   | /var/log/secure  | 记录验证和授权方面的信息 涉及账号密码的程序都会记录 例如系统登陆 sudo授权 切换用户等 |
   | /var/log/wtmp    | 永久记录所有用户的登陆注销信息 系统的启动重启关机事件 用last查看 |
   | /var/log/utmp    | 记录当前已登陆用户的信息 注意 只记录当前登陆用户的信息 会随着用户的登录和注销不断变化 要用w who users等命令查询 |

2. RPM产生的日志 在/var/log/相应的位置
3. 源码包的日志全部在手工安装的目录下



### 日志服务rsyslogd

1. 格式
2. 配置文件/etc/rsyslog.conf
   - [规则和日志等级](https://www.bilibili.com/video/BV1ut411a7ro?p=183)
   - [内容解释](https://www.bilibili.com/video/BV1ut411a7ro?p=184)

### 日志轮替

- 把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除
- 注意源码包的日志文件要手动加入轮替的配置文件
  - 命名-->/etc/logrotate.conf配置文件中的dateext参数
    - 日志会变成 logname-20200806
- /etc/logrotate.conf
  - 如果没写自己的轮替时间 就按开始自带写入的weekly
  - 其他同理
  - 打开看了看 很简单 没必要记了[参考](https://www.bilibili.com/video/BV1ut411a7ro?p=186) 写的时候 参考一下轮替代码里的命令
  - 平滑重启：  
    /bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &>/dev/null  
    如果有人正在访问 会等访问进程结束之后再重启服务
    - 注意：在重启服务**之前**也要重启rsyslogd  
      postrotate  
          /bin/kill -HUP `cat /var/run/syslogd.pid 2> /dev/null` 2> /dev/null || true  
      endscript
- 加入自己的日志轮替
  - 先写好自己的配置文件
  - logrotate 选项 配置文件名
    - -v：显示日志轮替过程
    - -f：强制进行日志轮替 不管是否已经符合条件


