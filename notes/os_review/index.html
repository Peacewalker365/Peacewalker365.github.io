<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.90.1" />
  <link rel="canonical" href="https://Peacewalker365.github.io/notes/os_review/">

  
    
    <meta name="description" content="von Neumann Architecture (realization of Turing Machine)
What are programs?   Process – a running program
  To allow for running multiple processes, a running program must be able to be interrupted
  OS provides a virtualization of CPUs, so each program can assume they have their “own” virtual CPU at its disposal
  Memory Space of a Program   A variable of a program corresponds to a location in memory">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">

  
  
  <title>OS Review Note | myStack</title>
</head>
  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">myStack</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/blogs/">Blog</a></li>
      
        <li><a href="/notes/">Note</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
        <li><a href="https://github.com/Peacewalker365">Github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1>OS Review Note</h1>
<p>von Neumann Architecture (realization of Turing Machine)</p>
<h3 id="what-are-programs">What are programs?</h3>
<ul>
<li>
<p>Process – a running program</p>
</li>
<li>
<p>To allow for running multiple processes, a running program must be able to be interrupted</p>
</li>
<li>
<p>OS provides a virtualization of CPUs, so each program can assume they have their “own” virtual CPU at its disposal</p>
</li>
</ul>
<h3 id="memory-space-of-a-program">Memory Space of a Program</h3>
<ul>
<li>
<p>A variable of a program corresponds to a location in memory</p>
</li>
<li>
<p>Code address, e.g., function entrance addresses, corresponds to a location in memory</p>
</li>
</ul>
<h3 id="concurrency">Concurrency</h3>
<ul>
<li>
<p>Two scenarios of concurrency</p>
<ul>
<li>Interleaving</li>
<li>Parallel execution</li>
</ul>
</li>
<li>
<p>Concurrency when happening on shared data</p>
<ul>
<li>May lead to undefined result under thread semantics</li>
<li>Have to apply synchronization to ensure consistent semantics</li>
</ul>
</li>
</ul>
<h3 id="three-easy-pieces">Three Easy Pieces</h3>
<ul>
<li>
<p>Virtualization</p>
</li>
<li>
<p>Concurrency</p>
</li>
<li>
<p>Persistence</p>
</li>
</ul>
<h3 id="how-cpu-virtualization-can-be-realized">How CPU virtualization can be realized</h3>
<ul>
<li>
<p><strong>One Straightforward Approach</strong></p>
<ul>
<li>OS emulates the real CPU
<ul>
<li>Each instruction is interpreted by the OS, as opposed to running on the bare metal.</li>
<li>OS has full control of a process, and can interrupt it at will.</li>
<li>OS can refuse to run an instruction that directly accesses I/O.</li>
<li>What is the drawback?
<ul>
<li>Very slow. Does not fully utilize the hardware’s capability</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Direct Execution</strong></p>
<ul>
<li>Let processes’ code run directly on CPU
<ul>
<li>How to preempt a running process?
<ul>
<li>Timer interrupt. Need to be frequent enough, e.g., every a few ms.</li>
<li>Interrupt handler is run upon an interrupt.</li>
<li>Interrupt is widely used to handle device I/O.</li>
<li>Exception can also interrupt a running process.</li>
</ul>
</li>
</ul>
</li>
<li>How to protect OS from the processes?
<ul>
<li>What about kernel code in memory?</li>
</ul>
</li>
<li>How to protect processes from one another?
<ul>
<li>Kernel needs to do A LOT OF book keeping.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Let’s introduce a few important concepts about processes</p>
</li>
<li>
<p>Let’s look at some important UNIX process APIs</p>
</li>
</ul>
<h3 id="what-are-the-main-problems-to-be-solved">What are the main problems to be solved?</h3>
<ul>
<li>
<p><strong>How to preempt a process</strong></p>
</li>
<li>
<p>How to protect shared resources, i.e., I/O    &ndash;I/O shall not be directly accessed by processes. <strong>All access to I/O must be mediated by OS.</strong></p>
<ul>
<li>The CPU must be able to distinguish two different modes: in one mode, the instructions running are those of the processes; in the other mode, the instructions running are those of the OS. We call the prior mode <strong>user mode</strong>, and the second mode <strong>kernel mode</strong>.</li>
<li><strong>Notion of OS Kernel:</strong>
<ul>
<li>An OS kernel consists of code that runs on behalf of the OS</li>
<li>N.B., this does not include OS library code</li>
</ul>
</li>
<li><strong>In user mode, certain instructions are not permitted</strong>. Examples?
<ul>
<li>If a process attempts to execute one such instruction, the CPU will <strong>raise an exception</strong> and the <strong>process will be interrupted</strong></li>
</ul>
</li>
<li><strong>In kernel mode, all instructions are allowed.</strong></li>
<li>When the <strong>CPU starts up</strong>, it is normally <strong>in kernel mode</strong>.</li>
<li><strong>Transition between the two modes.</strong>
<ul>
<li>from kernel to user &ndash; simpler, since OS is in control</li>
<li>from user to kernel &ndash; care must be taken to ensure protection</li>
</ul>
</li>
</ul>
</li>
<li>
<p>How to protect OS from the processes?           &ndash; wait until Virtual Memory</p>
</li>
<li>
<p>How to protect processes from one another.  &ndash; wait until Virtual Memory</p>
</li>
<li>
<p>Performance &amp; Efficiency</p>
</li>
<li>
<p>Other considerations</p>
<ul>
<li>Parallel execution</li>
</ul>
</li>
</ul>
<h3 id="context-switches">Context Switches</h3>
<ul>
<li>Always between user mode and kernel mode
<ul>
<li>Can a process directly switch to another process without going through kernel?
<ul>
<li>to do so the first process would need to access the other process&rsquo;s context information, and change the process&rsquo;s status to running</li>
<li>it will also need to switch to the other process&rsquo;s virtual memory.</li>
<li>It will be very hard to grant these privileges, without giving out too much.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Reasons for context switches/Cases of Trapping into Kernel</strong>
<ul>
<li><strong>Hardware interrupt</strong>
<ul>
<li>Timer</li>
<li>Device I/O</li>
<li>etc.</li>
</ul>
</li>
<li><strong>Exception</strong>
<ul>
<li>Illegal instruction</li>
<li>Non-permitted instruction</li>
</ul>
</li>
<li><strong>System calls</strong>
<ul>
<li>Requesting kernel to preform privileged operations on the process’s behalf</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="kernel-vs-user-mode">Kernel vs. User Mode</h3>
<ol>
<li><strong>Kernel code</strong> runs at <strong>full privilege</strong> (a.k.a. privileged execution)
<ul>
<li><strong>All instructions</strong> are <strong>available</strong></li>
<li><strong>All physical memory</strong> is <strong>available</strong></li>
<li><strong>Direct access to hardware I/O</strong> is <strong>available</strong></li>
</ul>
</li>
<li><strong>Process code</strong> runs at <strong>restricted privilege</strong>
<ul>
<li><strong>Certain instructions</strong> are <strong>not permitted</strong> – we will encounter quite a few</li>
<li><strong>Direct access to physical memory is not possible</strong> – more to be discussed later</li>
<li><strong>Direct access to hardware I/O is prohibited</strong></li>
</ul>
</li>
<li>Don’t take it for granted!</li>
</ol>
<h3 id="how-context-switches-can-be-implemented">How context switches can be implemented</h3>
<ol>
<li>How to <strong>trap into kernel</strong>
<ul>
<li><strong>hardware interrupt</strong>   e.g., timer interrupt&hellip;</li>
<li><strong>Save the context of the process interrupted</strong>
<ul>
<li>CPU saves PC value at the interrupt</li>
<li>CPU saves SR at the interrupt</li>
<li>CPU/OS saves GRs at the interrupt</li>
</ul>
</li>
<li><strong>Transfer control to kernel</strong>
<ul>
<li>CPU saves the current SP, find out the current process’s kernel stack through a special register, and changes SP to point to that kernel stack</li>
<li>CPU finds out the address of the IDT through a special register IDTR</li>
<li>CPU indexes into IDT, finds out the entrance address of the interrupt handler, and populates PC with the address</li>
<li>CPU changes from user mode to kernel mode</li>
</ul>
</li>
<li><strong>Update book-keeping</strong>
<ul>
<li>OS changes the interrupted process from ”running” to “ready” state</li>
<li>OS populates the relevant field in PCB regarding the interrupted process’s context info</li>
</ul>
</li>
</ul>
</li>
<li><strong>How to return from a trap</strong>
<ul>
<li>return from a special return instruction</li>
</ul>
</li>
<li><strong>How to switch to a different process while returning from a trap</strong></li>
</ol>
<p>basic notions:</p>
<ul>
<li>
<p>PC (program counter): CPU register pointing to the next instruction to fetch</p>
</li>
<li>
<p>SP (stack pointer): CPU register pointing to the current top of stack</p>
</li>
<li>
<p>GR (general registers): CPU general registers for storing temporary results</p>
</li>
<li>
<p>SR (status register): Current CPU status, e.g., arithmetic operation results</p>
</li>
<li>
<p><strong>A device notifies a CPU</strong> for an interrupting event <strong>through hard-wired signal</strong></p>
<ul>
<li>The CPU can tell which device has sent an interrupt</li>
<li>Interrupts from different devices are assigned different numbers, i.e., interrupt no.</li>
<li>CPU checks whether there is interrupt waiting, before fetching the next instruction</li>
</ul>
</li>
</ul>
<h3 id="case-study-x86-interrupt-mechanism">Case Study: x86 Interrupt Mechanism</h3>
<ul>
<li>Basic
<ul>
<li>PC (program counter): EIP</li>
<li>SP (stack pointer): ESP</li>
<li>GR (general registers): EAX, EBX, &hellip;</li>
<li>SR (status register): EFLAGS</li>
</ul>
</li>
<li>x86 adopts segmentation in addressing, so each address also needs to have a segment
<ul>
<li>For code, need to use the CS segment register
<ul>
<li>Thus program counter is CS:EIP</li>
</ul>
</li>
<li>For stack, need to use the SS segment register</li>
<li>Thus stack pointer is SS:ESP</li>
</ul>
</li>
</ul>
<h3 id="resume-execution-of-the-interrupted-process">Resume execution of the interrupted process</h3>
<ul>
<li>Revert the operating at the beginning of the interrupt
<ul>
<li>Restore the GRs to the value at interrupt</li>
<li>Restore SP/SR/PC to the value at interrupt</li>
<li>Change CPU mode from kernel to user</li>
</ul>
</li>
<li>Part of this is done through a “trap return” instruction
<ul>
<li>The semantics of the trap return instruction is the contract between the hardware and OS</li>
<li>The kernel can decide how to fulfill the rest</li>
</ul>
</li>
</ul>
<h3 id="resume-execution-of-a-different-process">Resume execution of a different process</h3>
<ul>
<li>Similar to before, but using another process’s context</li>
<li>Also need to change CPU register pointing to the new process’s kernel stack</li>
<li>OS needs to maintain each process’s context consistently, and be able to find the context when needed.</li>
</ul>
<h3 id="maintaining-each-processs-context">Maintaining each process’s context</h3>
<ul>
<li>It is extremely important that kernel maintains each process’s context consistently
<ul>
<li>The biggest part of an OS kernel’s job is book-keeping!</li>
</ul>
</li>
<li>Typically the kernel maintains a process control block (PCB) data structure for each active process.
<ul>
<li>The process’s current status</li>
<li>The process’s context to resume running</li>
<li>The process’s kernel stack (interrupt stack) location</li>
</ul>
</li>
</ul>
<h3 id="other-ways-of-trapping-into-kernel">Other ways of trapping into kernel</h3>
<ul>
<li>Exception
<ul>
<li>Similar to interrupt, except that when exception happens, the <strong>PC points to the offending instruction</strong>, as opposed to the next instruction</li>
<li>The hardware may <strong>inform CPU</strong> the specific nature of the exception <strong>through</strong> an <strong>error number</strong>.</li>
</ul>
</li>
<li>System call
<ul>
<li>User process explicitly traps into kernel, by invoking a specific interrupt number through “software interrupt”
<ul>
<li>In x86: the “int N” instruction</li>
<li><strong>System call number</strong> is <strong>passed through</strong> a <strong>register</strong>, in x86 it is %EAX</li>
<li>All <strong>parameters of a system call</strong> must be <strong>copied into kernel</strong> and <strong>checked</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="how-system-call-can-be-implemented">How system call can be implemented</h3>
<h3 id="important-unix-process-apis">Important UNIX process APIs</h3>
<ul>
<li>Unix History
<ul>
<li>Developed by Dennis Ritchie and Ken Thompson at AT&amp;T Bell Labs</li>
<li>Adapted some ideas from the Multics project in 1969</li>
</ul>
</li>
<li>Use man command to read manuals of commands and system calls
<ul>
<li>“man -a topic”: returns all entries on topic</li>
<li>Type “q” to exit an entry and move on to the next one</li>
</ul>
</li>
<li>UNIX Process APIs
<ul>
<li>fork()
<ul>
<li>Memory space, open files, environmental variables</li>
</ul>
</li>
<li>wait()</li>
<li>exec()</li>
</ul>
</li>
<li><strong>Redirecting input/output</strong>
<ul>
<li>An open file is assigned a numeric number as its “<strong>file descriptor</strong>”</li>
<li>0: standard input</li>
<li>1: standard output</li>
<li>2: standard error</li>
</ul>
</li>
<li>UNIX <strong>pipes</strong>:
<ul>
<li>pipe() <strong>returns a unidirectional message queue</strong> between processes <strong>for inter-process communication</strong>
<ul>
<li>Returns two file descriptors, d0 and d1.</li>
<li>Bytes written on d1 will be read from d0 in the same order.</li>
</ul>
</li>
</ul>
</li>
<li>Use the dup() system call to redirect standard input and output</li>
</ul>
<h2 id="cpu-scheduling">CPU Scheduling</h2>
<h3 id="policy-vs-mechanisms">Policy vs. Mechanisms</h3>
<ul>
<li>
<p>We have introduced the mechanism of context switches</p>
<ul>
<li>Before returning from kernel space to user space, OS needs to decide which user level process to resume</li>
</ul>
</li>
<li>
<p>The determination of the choice of which process to resume is the “Policy”</p>
</li>
</ul>
<h3 id="desired-properties-of-the-scheduling-policy">Desired Properties of the Scheduling Policy</h3>
<ul>
<li>
<p>What do you think are good outcomes (so we try to achieve them)</p>
<p><strong>Fair: Each process occupies about the same amount of CPU time</strong></p>
<p>This needs to be modulated through priority</p>
<ul>
<li><strong>I/O intensive processes</strong> shall have <strong>higher priority</strong></li>
<li>How to achieve fairness when every process has the same priority?
<ul>
<li>Two different notions of time: <strong>elapsed time</strong> vs. <strong>virtual time</strong></li>
<li><strong>OS</strong> can keep <strong>track</strong> of <strong>virtual time</strong> of all processes</li>
<li>Scheduler always <strong>pick</strong>s the one with <strong>the lowest virtual time</strong> to run</li>
</ul>
</li>
</ul>
</li>
<li>
<p>What do you think are bad outcomes (so we try to avoid them)</p>
<ul>
<li>What if a new process joins later? – needs to be adjusted
<ul>
<li>Approach 1: initialize a new process’s virtual time to that of the minimum of the currently ready processes</li>
</ul>
</li>
<li>What if a process was blocked in I/O, and is now ready to run. It will have a lower virtual time compared with the other ready processes.
<ul>
<li>Adversarial processes can potentially game the system to deprive other processes opportunity to make progress</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="goals-of-the-scheduling-policy">Goals of the Scheduling Policy</h3>
<ul>
<li>Metrics on which the algorithm tries to optimize
<ul>
<li><strong>Turnaround time</strong>
<ul>
<li>Average interval length from task arrival till completion</li>
</ul>
</li>
<li><strong>Response time (fairness)</strong>
<ul>
<li>Average interval length from task arrival till “response”</li>
<li>For simplicity, we interpret “response” as the first time a task is scheduled</li>
</ul>
</li>
</ul>
</li>
<li>The two metrics are trade-offs
<ul>
<li><strong>Optimizing on one will jeopardize the other</strong></li>
</ul>
</li>
</ul>
<h3 id="the-fifo-policy">The FIFO policy</h3>
<h3 id="shortest-time-to-completion-first-stcf">Shortest Time-to-Completion First (STCF)</h3>
<h3 id="shortest-job-first-sjf-historical-coverage">Shortest Job First (SJF) –Historical Coverage</h3>
<h3 id="round-robin">Round Robin</h3>
<h3 id="when-a-process-is-blocked-by-io">When a Process is Blocked by I/O</h3>
<ul>
<li>It cannot be scheduled until it is woken up
<ul>
<li>What shall the scheduling policy be?</li>
</ul>
</li>
<li>If a process is more interactive with users, it will more often be blocked by I/O.</li>
</ul>
<h2 id="two-well-known-scheduling-algorithms">Two Well Known Scheduling Algorithms</h2>

  

      </main>
      
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  </div>
  </body>
</html>