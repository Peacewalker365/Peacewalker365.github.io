<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="generator" content="Hugo 0.90.1" />
  <link rel="canonical" href="https://Peacewalker365.github.io/notes/persistence/">

  
    
    <meta name="description" content="persistence Closer to the CPU, faster
CPU–Mem–Graphics–
canonical protocol for programmed I/O Interface:
statue: busy or not
command
data
internal:
CPU
MEM
other chips
Q should the program running in kernel or user mode?
in kernel.
you don’t want the user level program to touch the devices directly, since devices are shared bewteen processes. Device doesn’t not have any protection from other processes. It can change the data on behalf of anyone.">
  

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" type="text/css" href="/css/paper.css">

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css">

  
  
  <title>Persistence Note | myStack</title>
</head>
  <body>
    <div class="container paper">
      <nav class="border split-nav">
  <div class="nav-brand">
    <h3><a href="/">myStack</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
    <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
      
        <li><a href="/blogs/">Blog</a></li>
      
        <li><a href="/notes/">Note</a></li>
      
        <li><a href="/tags/">Tags</a></li>
      
        <li><a href="/about/">About</a></li>
      
        <li><a href="https://github.com/Peacewalker365">Github</a></li>
      
      </ul>
    </div>
  </div>
</nav>
      <main>
        

<h1>Persistence Note</h1>
<h1 id="persistence">persistence</h1>
<p>Closer to the CPU, faster</p>
<p>CPU&ndash;Mem&ndash;Graphics&ndash;</p>
<h3 id="canonical-protocol-for-programmed-io">canonical protocol for programmed I/O</h3>
<p>Interface:</p>
<p>statue: busy or not</p>
<p>command</p>
<p>data</p>
<p>internal:</p>
<p>CPU</p>
<p>MEM</p>
<p>other chips</p>
<h3 id="q">Q</h3>
<p>should the program running in kernel or user mode?</p>
<p>in kernel.</p>
<p>you don&rsquo;t want the user level program to touch the devices directly, since devices are shared bewteen processes. Device doesn&rsquo;t not have any protection from other processes. It can change the data on behalf of anyone.</p>
<h3 id="key-features-of-programmed-io">key features of programmed IO</h3>
<p>CPU is involved every step of the way</p>
<p>A process invkes a system call, which results in device access</p>
<p>Under PIO, the process is spinning on the CPU waiting for the IO to complete</p>
<pre tabindex="0"><code>cons:

kernel involved everywhere

since devices are so slow compareing with cpu, cpu has to do a lot of unuseful spinning to do status check. just like what we do for the spinning lock.



pros:

simple and straight forward

cpu will keep checking so no time is wasted once the devices are available, so the responsive time is good.

</code></pre><h3 id="scheduling-picture">Scheduling Picture</h3>
<h3 id="other-approach-interrupt">Other approach: interrupt</h3>
<p>you don&rsquo;t need to keep pooling, the device will raise the exception to interrupt, and the handler will deal with it.</p>
<p>pro:</p>
<p>no wasting of cpu source</p>
<p>con:</p>
<p>if there are a lot of i/o devices, and they wake up one by one? the interrupts will happen consecutively.</p>
<p>So interrupt does have overhead.</p>
<h4 id="canonical-protocol-for-programmed-io-1">canonical protocol for programmed io</h4>
<p>very low latencty, it&rsquo;s watching. the moment it&rsquo;s ready, it leaves</p>
<h4 id="interrupt">interrupt</h4>
<p>need to  go wait and switch back. overhead always there. Latency</p>
<p>for some device it&rsquo;s ok, but not for everyone.</p>
<h4 id="use-programmed-io-if-fast-response-is-needed">use programmed io if fast response is needed</h4>
<p>Q:</p>
<p>if a process si running in the interrupt mode in a system call, and it goes to sleep. which mode is the process in? (running ready blocked?)</p>
<p>it&rsquo;s blocked.</p>
<p>instead in programmed io mode, the process is running.</p>
<h3 id="further-improvement-dma">Further improvement: DMA</h3>
<ul>
<li>even with interrupt, cpu is still involved in all data transfers</li>
<li>Direct Memory Access allows devices to transfer data to/from memory without CPU involvement.
<ul>
<li>CPU sets up DMA, and context switch to run other process</li>
<li>when mem transfer finishes, interrupt raised</li>
<li>Kernel interrupt handler runs and wakes up the sleeping process</li>
</ul>
</li>
</ul>
<h4 id="dma-uses-kernel-page-table">DMA uses kernel page table</h4>
<p>there are some space reserved for dma so that kernel know where they are, just like how driver files are set.</p>
<p>the kernel page table can have physical mem 1-1 matched</p>
<h4 id="scheduling-pic">scheduling pic</h4>
<h3 id="device-driver">Device Driver</h3>
<ul>
<li>software dealing with devices</li>
<li>part of kernel (a big portion)</li>
<li>provide uniform abstraction for OS to interact with various types of devices</li>
</ul>
<h3 id="linux-software-stack-regarding-file-system">Linux software stack regarding File System</h3>
<h4 id="assuming-we-have-4-disks">Assuming we have 4 disks!!!</h4>
<h3 id="raid-redundant-arrays-of-inexpensive-disks">RAID: redundant arrays of inexpensive disks</h3>
<p>RAID0: no replication &ndash;&gt; Striping</p>
<p>capacity: 4 * S bytes, where each disk store S bytes</p>
<p>performance:</p>
<p>sequential read/write: 4 * times bandwidth</p>
<p>random read/write: same as snigle disk</p>
<p>reliability:  no improvement on reliability, any disk failure means the sys fails</p>
<p>RAID1: mirror data across two or more disks &ndash;&gt; mirroring</p>
<p>RAID1-0:</p>
<p>stripe of mirror &ndash;&gt;</p>
<p>0011</p>
<p>2233</p>
<p>4455</p>
<p>6677</p>
<p>mirror of strip &ndash;&gt;</p>
<p>0101</p>
<p>2323</p>
<p>4545</p>
<p>6767</p>
<p>capacity:</p>
<p>performance: 2 * S</p>
<p>sequential read: 2 times since the disk head moving take time to skip blocks</p>
<p>sequential write: 2 * bandwidth as a single disk</p>
<p>random read: same as single</p>
<p>random write: write both copys at same time, about the same as single disk, slightly higher</p>
<p>Reliability: Tolerate one total disk failure</p>
<p>RAID4/5: split data across disks</p>
<p>bit-wise XOR all blocks in the same stripe, and store the result in the parity block</p>
<p>Can reconstruct any missing block from the others</p>
<p>RAID 4/5 differ on how parity blocks are distributed</p>
<p>read is like raid 0 with one fewer disk</p>
<p>write will additionly write the parity disk!</p>
<p>for example, if we only change 2, then we can change P0 by (old_p0 XOR old_2) XOR new_2</p>
<p>so To write one block:</p>
<p>read old data</p>
<p>read old p</p>
<p>write new data</p>
<p>write new p = (old_p0 XOR old_2) XOR new_2</p>
<p>RAID4</p>
<p>0123 P0</p>
<p>4567 P2</p>
<p>&hellip;</p>
<p>Performance:</p>
<p>the writing process is bottle neck</p>
<p>RAID5: rotating parity</p>
<p>p0 0 1 2 3</p>
<p>4 p1 5 6 7</p>
<p>&hellip;</p>
<p>Raid4/5:</p>
<p>capacity: 4 * S bytes</p>
<p>performance:</p>
<p>sequential read: 4</p>
<p>sequential write: bottle necked by parity disk for raid 4, improve for raid5</p>
<p>Reliability: any single disk failure can be tolerated</p>
<h3 id="unix-file-system">Unix File System</h3>
<p>to understand the design principles of a very important file system</p>
<h4 id="a-few-main-considerations-in-unix-file-sys-design">A few main considerations in Unix File sys Design</h4>
<ul>
<li>provide a uniform structure for naming and accessing data objects throughout the system</li>
<li>Enable data sharing between different programs</li>
<li>Ensure consistency with concurrent access</li>
<li>acheve good performance/reliability balance
<ul>
<li>hard drive is slow, buffer si important</li>
<li>care need to be taken to account for failure</li>
</ul>
</li>
</ul>
<h4 id="naming-file">Naming file</h4>
<p>file are organized in a directory tree</p>
<p>a dir is also a file &mdash;&gt; mapping from name to inode</p>
<p>inode is the Unix sys internal data structure for a file</p>
<p>​	inode number uniquely identifies a file across the system</p>
<h4 id="file-sys-metadata">FIle sys Metadata</h4>
<ul>
<li>Inode: stored in persistent storage, and cached in mem for faster access</li>
<li>Directory: special file that contains mapping from names in that dir to their inode numbers</li>
</ul>
<h4 id="operating-on-files">Operating on Files</h4>

  

      </main>
      
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-123456789-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  </div>
  </body>
</html>